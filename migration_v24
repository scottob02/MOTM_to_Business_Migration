#!/bin/zsh

#
# ─── SCRIPT CONFIGURATION ─────────────────────────────────────────────────────
#

# --- Deferral Settings ---
MAX_DEFERRALS=5
PLIST_PATH="/Library/Application Support/LBG/com.lbg.jamf-migration.plist"
LOGGED_IN_USER=$(scutil <<< "show State:/Users/ConsoleUser" | awk '/Name :/ && ! /loginwindow/ { print $3 }')
USER_UID=$(id -u "$LOGGED_IN_USER")
LAUNCH_AGENT_PATH="/Users/$LOGGED_IN_USER/Library/LaunchAgents/com.lbg.jamf-migration.plist"


# --- SwiftDialog Settings ---
DIALOG_BINARY="/usr/local/bin/dialog"
# This should point to the icon in your local branding package
BRANDING_ICON="/Users/Shared/LBG_Branding_Cancara/lbg_primary_logo.png" 

# --- Jamf API Credentials & Endpoints ---
JAMF_CLIENT_ID="${4:-$JAMF_CLIENT_ID}"
JAMF_CLIENT_SECRET="${5:-$JAMF_CLIENT_SECRET}"
ORIGIN_JAMF_URL="${6:-$ORIGIN_JAMF_URL}"
TARGET_JAMF_URL="${7:-$TARGET_JAMF_URL}"
DRY_RUN="${8:-${DRY_RUN:-false}}"

# --- Global Variables ---
management_id=""
computer_id=""

#
# ─── LOGGING AND UTILITIES ────────────────────────────────────────────────────
#

LOG_FILE="/Users/$LOGGED_IN_USER/jamf_migration_preflight.log"
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'; NC='\033[0m'

log() {
  printf '%b[%s] [INFO]  %s%b\n' \
    "$YELLOW" "$(date '+%Y-%m-%dT%H:%M:%S')" "$1" "$NC" | tee -a "$LOG_FILE"
}

success() {
  printf '%b[%s] [SUCCESS] %s%b\n' \
    "$GREEN" "$(date '+%Y-%m-%dT%H:%M:%S')" "$1" "$NC" | tee -a "$LOG_FILE"
}

err() {
  local error_message="$1"
  printf '%b[%s] [ERROR] %s%b\n' \
    "$RED" "$(date '+%Y-%m-%dT%H:%M:%S')" "$error_message" "$NC" | tee -a "$LOG_FILE" >&2
  # Avoid showing dialog if already exiting due to dialog interaction (exit codes 2, 3, 4)
  # Also check if DIALOG_BINARY exists before trying to show error
  if [[ -x "$DIALOG_BINARY" ]] && ! [[ "$?" =~ ^(2|3|4)$ ]]; then 
      show_dialog_error "$error_message"
  fi
  exit 1
}


run_cmd() {
  if $dry_run && [[ "$1" == "kill" ]]; then
    log "[DRY-RUN] Would execute: $*"
  else
    "$@"
  fi
}

urlencode() {
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * )               printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "${encoded}"
}


#
# ─── SWIFTDIALOG FUNCTIONS ────────────────────────────────────────────────────
#

# Check if dialog binary exists
if [[ ! -x "$DIALOG_BINARY" ]]; then
    log "ERROR: SwiftDialog binary not found or not executable at $DIALOG_BINARY."
    # Use osascript for a basic alert if dialog isn't available
    osascript -e 'display alert "Migration Error" message "SwiftDialog is required but not found. Please contact IT support." as critical'
    exit 1
fi

show_dialog_error() {
  "$DIALOG_BINARY" --title "Migration Error" --message "$1" --icon "SF=xmark.octagon.fill,colour=red" \
    --button1text "Close" --width 450 --height 250 --messagefont "size=12" --json &>/dev/null 
    # Capture output to avoid errors if dialog fails, ignore json output
}

show_dialog_info() {
    "$DIALOG_BINARY" --title "$1" --message "$2" --icon "$BRANDING_ICON" \
      --button1text "OK" --width 450 --height 250 --messagefont "size=12" --json &>/dev/null
}

show_dialog_confirm() {
    # Returns 0 if Button 1 pressed, 2 if Button 2 pressed
    "$DIALOG_BINARY" --title "$1" --message "$2" --icon "$BRANDING_ICON" \
      --button1text "${3:-Proceed}" --button2text "${4:-Cancel}" --width 550 --height 350 --messagefont "size=12" --json &>/dev/null
    return $?
}


#
# ─── DEFERRAL & SCHEDULING FUNCTIONS ──────────────────────────────────────────
#

schedule_relaunch() {
    local schedule_type="$1"
    local custom_epoch="$2" # Expecting epoch time for custom schedule

    local target_hour
    local target_minute
    local target_day
    local target_month
    local target_year
    local current_epoch=$(date +%s)

    log "Scheduling relaunch based on type: $schedule_type"

    case "$schedule_type" in
        "1hour")
            target_epoch=$((current_epoch + 3600))
            ;;
        "2hour")
            target_epoch=$((current_epoch + 7200))
            ;;
        "tomorrow9am")
             # Calculate epoch for tomorrow 9 AM
            local tomorrow_date=$(date -v+1d +%Y-%m-%d)
            target_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$tomorrow_date 09:00:00" +%s)
            # Ensure it's in the future (handles edge case if run exactly at 9am)
            [[ "$target_epoch" -le "$current_epoch" ]] && target_epoch=$(date -j -v+1d -f "%Y-%m-%d %H:%M:%S" "$tomorrow_date 09:00:00" +%s)
            ;;
        "eod") # End of Day (Today 5 PM = 17:00)
            local today_date=$(date +%Y-%m-%d)
            target_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$today_date 17:00:00" +%s)
            # If it's already past 5 PM today, schedule for tomorrow 5 PM
            if [[ "$current_epoch" -ge "$target_epoch" ]]; then
                log "Current time is past 5 PM, scheduling for tomorrow 5 PM."
                local tomorrow_date=$(date -v+1d +%Y-%m-%d)
                target_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$tomorrow_date 17:00:00" +%s)
            fi
            ;;
        "1day") # In 1 Day (Tomorrow at 9 AM for consistency)
            local tomorrow_date=$(date -v+1d +%Y-%m-%d)
            target_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$tomorrow_date 09:00:00" +%s)
             # Ensure it's in the future
            [[ "$target_epoch" -le "$current_epoch" ]] && target_epoch=$(date -j -v+1d -f "%Y-%m-%d %H:%M:%S" "$tomorrow_date 09:00:00" +%s)
           ;;
        "custom")
            if [[ -z "$custom_epoch" || ! "$custom_epoch" =~ ^[0-9]+$ ]]; then
                err "Invalid custom epoch time provided for scheduling."
            fi
            target_epoch="$custom_epoch"
            # Basic validation: ensure custom time is in the future
            if [[ "$target_epoch" -le "$current_epoch" ]]; then
                 err "Custom deferral time must be in the future."
            fi
             # Basic validation: ensure custom time is within 7 days
            local seven_days_later=$((current_epoch + 604800)) # 7 * 24 * 60 * 60
            if [[ "$target_epoch" -gt "$seven_days_later" ]]; then
                err "Custom deferral time cannot be more than 7 days in the future."
            fi
            ;;
        *)
            err "Invalid schedule type '$schedule_type'"
            ;;
    esac

    # Convert target epoch back to date components for the plist
    target_year=$(date -r "$target_epoch" +%Y)
    target_month=$(date -r "$target_epoch" +%m)
    target_day=$(date -r "$target_epoch" +%d)
    target_hour=$(date -r "$target_epoch" +%H)
    target_minute=$(date -r "$target_epoch" +%M)

    log "Calculated Target - Year:$target_year, Month:$target_month, Day:$target_day, Hour:$target_hour, Minute:$target_minute"

    # Unload any existing agent
    if [ -f "$LAUNCH_AGENT_PATH" ]; then
        launchctl bootout "gui/$USER_UID" "$LAUNCH_AGENT_PATH" &>/dev/null
    fi

    # Create the launch agent plist using StartCalendarInterval
    cat << EOF > "$LAUNCH_AGENT_PATH"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.lbg.jamf-migration</string>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/zsh</string>
        <string>$0</string> <!-- Rerun this script -->
    </array>
    <key>StartCalendarInterval</key>
    <dict>
        <key>Year</key>
        <integer>$target_year</integer>
        <key>Month</key>
        <integer>$target_month</integer>
        <key>Day</key>
        <integer>$target_day</integer>
        <key>Hour</key>
        <integer>$target_hour</integer>
        <key>Minute</key>
        <integer>$target_minute</integer>
    </dict>
    <key>RunAtLoad</key>
    <false/>
</dict>
</plist>
EOF

    # Set correct ownership and permissions
    chown "$LOGGED_IN_USER" "$LAUNCH_AGENT_PATH"
    chmod 644 "$LAUNCH_AGENT_PATH"

    # Load the new agent using the correct UID
    launchctl bootstrap "gui/$USER_UID" "$LAUNCH_AGENT_PATH"
    log "Launch Agent loaded and scheduled for $target_year-$target_month-$target_day $target_hour:$target_minute."
}


remove_relaunch_agent() {
    if [ -f "$LAUNCH_AGENT_PATH" ]; then
        log "Removing relaunch agent."
        launchctl bootout "gui/$USER_UID" "$LAUNCH_AGENT_PATH" &>/dev/null
        rm "$LAUNCH_AGENT_PATH"
    fi
}

handle_deferral() {
    deferral_count=$((deferral_count + 1))
    defaults write "$PLIST_PATH" DeferralCount -int "$deferral_count"
    log "User deferred. New count: $deferral_count."

    # Use SwiftDialog dropdown for deferral options, adding 'custom'
    defer_choice_output=$("$DIALOG_BINARY" --title "Choose Deferral Time" \
      --message "When should we remind you?\n\nYou have $((MAX_DEFERRALS - deferral_count)) deferrals remaining." \
      --icon "$BRANDING_ICON" --width 450 --height 300 --messagefont "size=12" \
      --selecttitle "Deferral Options" --selectvalues "1hour, 2hour, tomorrow9am, eod, 1day, custom" \
      --selectvaluekey "value" --selectnamekey "name" \
      --selectoptions '[
          {"name": "Remind me in 1 Hour", "value": "1hour"},
          {"name": "Remind me in 2 Hours", "value": "2hour"},
          {"name": "Tomorrow Morning (9 AM)", "value": "tomorrow9am"},
          {"name": "End of Day (Today 5 PM)", "value": "eod"},
          {"name": "Remind me in 1 Day (Tomorrow 9 AM)", "value": "1day"},
          {"name": "Choose Specific Date/Time...", "value": "custom"}
      ]' \
      --selectdefault "1hour" \
      --selectrequired \
      --button1text "Confirm Deferral" --button2text "Cancel" --json)
      
    defer_choice_exit_code=$?
    
    if [[ $defer_choice_exit_code -eq 2 ]]; then
        log "User cancelled deferral selection."
        exit 0 # Exit gracefully
    elif [[ $defer_choice_exit_code -ne 0 ]]; then
        err "Error displaying deferral options dialog. Exit Code: $defer_choice_exit_code"
    fi

    selected_deferral=$(echo "$defer_choice_output" | jq -r '.SelectedOption')

    if [[ -z "$selected_deferral" || "$selected_deferral" == "null" ]]; then
        err "Could not determine selected deferral option from dialog output."
    fi

    log "User selected deferral option: $selected_deferral"

    local defer_message=""
    local custom_epoch_time=""

    if [[ "$selected_deferral" == "custom" ]]; then
        # Show date picker dialog
        local current_epoch=$(date +%s)
        local max_epoch=$((current_epoch + 604800)) # 7 days from now
        local max_date_iso=$(date -r "$max_epoch" '+%Y-%m-%d %H:%M:%S')

        log "Displaying custom date/time picker..."
        datepicker_output=$("$DIALOG_BINARY" --title "Select Custom Deferral Time" \
          --message "Choose a date and time within the next 7 days." \
          --icon "$BRANDING_ICON" --width 450 --height 300 --messagefont "size=12" \
          --datepicker --dateformat "yyyy-MM-dd HH:mm" \
          --button1text "Set Time" --button2text "Cancel" --json)

        datepicker_exit_code=$?

        if [[ $datepicker_exit_code -eq 2 ]]; then
            log "User cancelled custom date/time selection."
            # Optionally, loop back to main deferral choice or just exit
            exit 0
        elif [[ $datepicker_exit_code -ne 0 ]]; then
            err "Error displaying date picker dialog. Exit Code: $datepicker_exit_code"
        fi

        local selected_date_str=$(echo "$datepicker_output" | jq -r '.SelectedDate')
        if [[ -z "$selected_date_str" || "$selected_date_str" == "null" ]]; then
             err "Could not get selected date/time from date picker."
        fi

        log "Custom date/time string selected: $selected_date_str"
        # Convert selected date string to epoch time
        custom_epoch_time=$(date -j -f "%Y-%m-%d %H:%M" "$selected_date_str" +%s 2>/dev/null) # Adjusted format slightly
        if [[ $? -ne 0 || -z "$custom_epoch_time" ]]; then
            err "Invalid date/time format received from date picker: $selected_date_str"
        fi
        
        # Validate custom time (future and within 7 days) - done in schedule_relaunch
        local formatted_custom_time=$(date -r "$custom_epoch_time" '+%Y-%m-%d at %I:%M %p')
        defer_message="You will be reminded on $formatted_custom_time."
        
    else
        # Standard deferral messages
        case "$selected_deferral" in
            "1hour") defer_message="You will be reminded in 1 hour." ;;
            "2hour") defer_message="You will be reminded in 2 hours." ;;
            "tomorrow9am") defer_message="You will be reminded tomorrow at 9 AM." ;;
            "eod") 
                if [[ $(date +%H) -ge 17 ]]; then defer_message="You will be reminded tomorrow at 5 PM."; else defer_message="You will be reminded today at 5 PM."; fi ;;
            "1day") defer_message="You will be reminded tomorrow at 9 AM." ;; 
            *) err "Invalid deferral option selected: $selected_deferral" ;; # Should not happen
        esac
    fi

    # Schedule the relaunch
    schedule_relaunch "$selected_deferral" "$custom_epoch_time"
    
    # Show confirmation
    show_dialog_info "Migration Deferred" "$defer_message"
    exit 0 # Exit after deferral is set
}


check_deferral() {
  if [ ! -f "$PLIST_PATH" ]; then
    log "Deferral plist not found at '$PLIST_PATH'. Creating with 0 deferrals."
    # Ensure directory exists before writing
    mkdir -p "$(dirname "$PLIST_PATH")"
    if ! defaults write "$PLIST_PATH" DeferralCount -int 0; then
       err "Failed to create deferral plist at '$PLIST_PATH'. Check permissions."
    fi
  fi
  
  deferral_count=$(defaults read "$PLIST_PATH" DeferralCount 2>/dev/null)
  # Handle case where key exists but isn't an integer or plist is corrupt
   if ! [[ "$deferral_count" =~ ^[0-9]+$ ]]; then
        log "WARN: Invalid deferral count found. Resetting to 0."
        defaults write "$PLIST_PATH" DeferralCount -int 0
        deferral_count=0
   fi
   
  remaining_deferrals=$((MAX_DEFERRALS - deferral_count))

  log "Deferral count: $deferral_count. Maximum allowed: $MAX_DEFERRALS. Remaining: $remaining_deferrals."

  if [ "$remaining_deferrals" -le 0 ]; then
    log "No deferrals remaining. Migration is mandatory."
    show_dialog_info "Mandatory Migration" "The migration is now mandatory.\nPlease save your work, the process will begin automatically after closing this window."
    remove_relaunch_agent # Clean up scheduler as it's no longer needed
  else
    # Use show_dialog_confirm and check its exit status
    if show_dialog_confirm "Jamf Pro Migration Required" "This Mac needs to be migrated to a new management system.\n\nYou have $remaining_deferrals deferrals remaining." "Migrate Now" "Defer"; then
        # Exit status 0 means "Migrate Now" was pressed
        log "User chose to migrate now."
        remove_relaunch_agent # Clean up scheduler
    else
        # Exit status 2 means "Defer" was pressed
        log "User chose to defer."
        handle_deferral # This function now handles scheduling and exits the script
    fi
  fi
}

show_requirements_dialog() {
    local power_status_checked="false"
    local power_status_icon="SF=xmark.circle.fill,colour=red" # Using SF Symbols
    if pmset -g batt | grep -q "AC Power"; then
        power_status_checked="true"
        power_status_icon="SF=checkmark.circle.fill,colour=green"
    fi
    
    local dialog_cmd
    local dialog_output
    local dialog_exit_code
    local all_required_checked="false"

    while [[ "$all_required_checked" != "true" ]]; do
        # Note the change in checkbox syntax: just the string for label/options
        dialog_cmd=(
            "$DIALOG_BINARY"
            --title "Migration Requirements Checklist"
            --message "Please confirm the following before proceeding.\n**This process will wipe all data from your Mac.**"
            --icon "$BRANDING_ICON"
            --width 650 --height 450 --messagefont "size=12" --alignment "left"
            --checkbox "style=switch, label=**Power:** Your Mac is connected to a power adapter., checked=$power_status_checked, disabled, icon=$power_status_icon" 
            --checkbox "style=switch, label=**Internet:** You have a stable internet connection., required, icon=SF=wifi"
            --checkbox "style=switch, label=**Disk Space:** You have at least 5 GB of free disk space., required, icon=SF=opticaldiscdrive"
            --checkbox "style=switch, label=**OneDrive Backup:** I confirm all important data is saved/synced to OneDrive., required, icon=SF=cloud.fill"
            --checkbox "style=switch, label=**Time Sync:** System clock is set automatically., required, icon=SF=clock.fill"
            --button1text "Continue" --button1disabled # Start with Continue disabled
            --button2text "Cancel"
            --json
        )

        dialog_output=$("${dialog_cmd[@]}")
        dialog_exit_code=$?

        log "Requirements dialog exit code: $dialog_exit_code"
        # log "Requirements dialog output: $dialog_output" # Can be verbose, enable if needed

        if [[ $dialog_exit_code -eq 2 ]]; then
            log "User cancelled at the requirements checklist."
            exit 0 # Exit gracefully
        elif [[ $dialog_exit_code -ne 0 ]]; then
            # Check if output contains checkbox data - if so, user likely interacted, enable Continue
             if echo "$dialog_output" | jq -e '.checkbox' > /dev/null; then
                 log "Checkbox interaction detected, enabling Continue button..."
                 # Update dialog command to enable button1
                 dialog_cmd[${#dialog_cmd[@]}-4]="--button1text Continue" # Re-enable button
                 # Rerun the dialog command with the updated state
                 dialog_output=$("${dialog_cmd[@]}")
                 dialog_exit_code=$?
                 log "Reran dialog, exit code: $dialog_exit_code"
                
                 if [[ $dialog_exit_code -eq 2 ]]; then log "User cancelled after interaction."; exit 0; fi
                 if [[ $dialog_exit_code -ne 0 ]]; then err "Error re-displaying requirements dialog after interaction."; fi

             else
                # If no checkbox data, it's likely a real error or unexpected close
                err "Error displaying requirements dialog or dialog closed unexpectedly. Exit Code: $dialog_exit_code"
            fi
        fi
        
        # If exit code is 0 (Continue pressed), validate checkboxes
        if [[ $dialog_exit_code -eq 0 ]]; then
             # Extract states (indexes adjusted for SF symbols potentially changing order, use jq filters)
             local internet_ok=$(echo "$dialog_output" | jq -r '.checkbox[] | select(.label | contains("Internet")) | .checked // "false"')
             local disk_ok=$(echo "$dialog_output" | jq -r '.checkbox[] | select(.label | contains("Disk Space")) | .checked // "false"')
             local backup_ok=$(echo "$dialog_output" | jq -r '.checkbox[] | select(.label | contains("OneDrive Backup")) | .checked // "false"')
             local time_ok=$(echo "$dialog_output" | jq -r '.checkbox[] | select(.label | contains("Time Sync")) | .checked // "false"')

             log "Checkbox states: Internet=$internet_ok, Disk=$disk_ok, Backup=$backup_ok, Time=$time_ok"

             if [[ "$internet_ok" == "true" && "$disk_ok" == "true" && "$backup_ok" == "true" && "$time_ok" == "true" ]]; then
                 all_required_checked="true"
                 log "All required checkboxes confirmed by user."
             else
                 log "Not all required checkboxes were checked."
                 show_dialog_error "Confirmation Required\n\nPlease check all required boxes (Internet, Disk Space, OneDrive Backup, Time Sync) before continuing."
                 # Loop continues
             fi
        fi
        
    done
    success "User confirmed all migration requirements."
}



#
# ─── ENVIRONMENT & PREFLIGHT CHECKS ───────────────────────────────────────────
#

setup_environment() {
    # Validate required parameters
    local missing_params=false
    local error_msg="Missing required parameters:"

    if [ -z "$JAMF_CLIENT_ID" ]; then error_msg+="\n- JAMF_CLIENT_ID"; missing_params=true; fi
    if [ -z "$JAMF_CLIENT_SECRET" ]; then error_msg+="\n- JAMF_CLIENT_SECRET"; missing_params=true; fi
    if [ -z "$ORIGIN_JAMF_URL" ]; then error_msg+="\n- ORIGIN_JAMF_URL"; missing_params=true; fi
    if [ -z "$TARGET_JAMF_URL" ]; then error_msg+="\n- TARGET_JAMF_URL"; missing_params=true; fi

    if $missing_params; then
      err "$error_msg"
    fi

    client_id="$JAMF_CLIENT_ID"
    client_secret="$JAMF_CLIENT_SECRET"
    origin_jamf_url="${ORIGIN_JAMF_URL%/}"
    target_jamf_url="${TARGET_JAMF_URL%/}"
    dry_run=$(echo "$DRY_RUN" | tr '[:upper:]' '[:lower:]')
    [[ "$dry_run" == "true" ]] && dry_run=true || dry_run=false

    log_dir=$(dirname "$LOG_FILE")
    mkdir -p "$log_dir" 2>/dev/null
    # Check write permissions for log file/directory
    if ! touch "$LOG_FILE" 2>/dev/null; then
        echo "ERROR: Cannot write to log file $LOG_FILE. Check permissions for user $LOGGED_IN_USER in $log_dir"
        # Use osascript for alert as SwiftDialog might rely on user context we don't have yet
        osascript -e 'display alert "Migration Error" message "Cannot write log file. Please contact IT support." as critical'
        exit 1; 
    fi
    log "Log file setup successful at $LOG_FILE"

    serial=$(system_profiler SPHardwareDataType | awk '/Serial/ {print $4}')
    [ -z "$serial" ] && err "Could not determine serial number."
    log "Device Serial Number: $serial"
}

check_hardware_support() {
    log "Checking hardware for Apple Silicon..."
    if ! sysctl -n machdep.cpu.brand_string | grep -q "Apple"; then
        err "This device is not an Apple Silicon Mac and is no longer supported. Please follow the process to order a new device."
    fi
    success "Apple Silicon Mac detected. Device is supported."
}

check_os_version() {
    log "Checking macOS version..."
    OS_VERSION=$(sw_vers -productVersion)
    local os_major_version
    os_major_version=$(echo "$OS_VERSION" | awk -F. '{print $1}')

    if [[ "$os_major_version" -lt 12 ]]; then
        err "macOS version ($OS_VERSION) is older than macOS 12. This migration requires macOS 12 or newer."
    else
        success "macOS version ($OS_VERSION) is supported."
    fi
}

get_connection_type() {
  log "Checking internet connection..."
  # Use a reliable target and increase timeout slightly
  if ! curl -s --head --connect-timeout 10 "https://www.apple.com/" >/dev/null 2>&1; then
    err "No internet connectivity detected (cannot reach apple.com). Migration requires an active internet connection."
  fi
  success "Internet connectivity check passed."
}

check_device_power_type() {
  log "Checking power source..."
  # This check is informational now, confirmation happens in the dialog
  if pmset -g batt | grep -q "AC Power"; then
    success "Device is connected to AC power."
  else
    # This might fail the run if not plugged in, which is good.
    # The interactive check reinforces this.
    err "Device is not connected to AC power. Please connect your power adapter and rerun the migration tool."
  fi
}

check_mdm_profile() {
  log "Checking for active MDM profile..."
  # Check more reliably using the profiles command output
  local profile_info
  profile_info=$(profiles show -type enrollment 2>/dev/null)
  
  if [[ -z "$profile_info" ]]; then
       # Fallback check if the first command fails entirely
       if ! profiles status -type enrollment | grep -q "Enrolled via DEP:"; then
           err "No active MDM profile was detected. This device must be enrolled in MDM to proceed."
       fi
  elif ! echo "$profile_info" | grep -q "Enrolled via"; then # Look for generic enrollment string
       err "No active MDM profile enrollment detected via 'profiles show'. This device must be enrolled in MDM."
  fi
  success "Active MDM profile detected."
}


check_jamf_enrollment() {
  log "Verifying current Jamf Pro enrollment status..."
  local jamf_binary=""
  if [[ -x "/usr/local/bin/jamf" ]]; then jamf_binary="/usr/local/bin/jamf"; 
  elif [[ -x "/usr/local/jamf/bin/jamf" ]]; then jamf_binary="/usr/local/jamf/bin/jamf"; 
  else err "Jamf binary not found or not executable. Device may not be enrolled correctly."; fi
  log "Using Jamf binary at $jamf_binary"
  
  local current_jss_url=""
  # Prefer reading plist first as it's faster
  if [[ -f "/Library/Preferences/com.jamfsoftware.jamf.plist" ]]; then
      current_jss_url=$(/usr/bin/defaults read /Library/Preferences/com.jamfsoftware.jamf.plist jss_url 2>/dev/null)
  fi

  # Fallback: Ask jamf binary if plist read fails or file doesn't exist
  if [[ -z "$current_jss_url" ]]; then
       log "Plist method failed, trying 'jamf checkJSSConnection'..."
       # Use timeout to prevent hangs on network issues
       current_jss_url=$(timeout 10 "$jamf_binary" checkJSSConnection -dump | awk '/url: / {print $2}')
       if [[ $? -ne 0 ]]; then
            log "WARN: 'jamf checkJSSConnection' timed out or failed. Enrollment check might be inaccurate."
       fi
  fi

  if [[ -z "$current_jss_url" ]]; then
      err "Could not determine the current Jamf Pro server URL after checking plist and binary."
  fi

  log "Current Jamf URL determined: $current_jss_url"
  
  # Normalize URLs by removing trailing slashes before comparison
  local norm_current_url="${current_jss_url%/}"
  local norm_target_url="${target_jamf_url%/}"
  local norm_origin_url="${origin_jamf_url%/}"

  if [[ "$norm_current_url" == "$norm_target_url" ]]; then
    err "Device is already enrolled in the target Jamf Pro instance ($target_jamf_url). Migration unnecessary."
  elif [[ "$norm_current_url" != "$norm_origin_url" ]]; then
    err "Device is enrolled in an unexpected Jamf Pro instance ($current_jss_url), not the expected origin ($origin_jamf_url). Cannot proceed."
  else
    success "Confirmed device is enrolled in the correct origin Jamf instance ($origin_jamf_url)."
  fi
}

check_onedrive_status() {
    log "Checking OneDrive installation..."
    # Only check if it's installed, rely on user confirmation for sync status
    if [[ ! -d "/Applications/OneDrive.app" ]]; then
        err "OneDrive.app is not installed. Please install OneDrive and ensure your data is synced before proceeding."
    fi
    success "OneDrive application is installed."
}


kill_user_apps() {
  # Refined list of essential processes to exclude
  local excluded_patterns=(
      "Self Service" "Terminal" "Finder" "dialog" "[j]amf" "loginwindow" # Use [j]amf to avoid matching grep itself
      "WindowServer" "SystemUIServer" "Dock" "[m]ds" "Spotlight" "NotificationCenter" # Core macOS UI
      "Symantec" "WSSAgent" "[M]icrosoft Defender" "[M]sSense" "[w]dav" # Security/Network - added specific WSS name, used brackets
      "coreauthd" "securityd" "runningboardd" "UserEventAgent" # Core Services
      "ControlCenter" "SoftwareUpdateNotificationManager" # More UI/System agents
      "OneDrive" # Keep OneDrive running longer if possible
      "SecurityAgent" "universalAccessAuthWarn" # Auth prompts
      "screencapture" # Avoid killing screenshot processes
      "kernel_task" "launchd" "distnoted" # Fundamental system processes
      )
  log "Starting graceful application termination (excluding critical processes)..."
  
  local app_pids=()
  # Get PIDs of apps owned by the logged-in user that seem like GUI apps
  # Avoid running heavy ps commands repeatedly in loop if possible
  # Get all user processes first
  all_user_procs=$(ps -x -o pid,command -u "$LOGGED_IN_USER")

  echo "$all_user_procs" | grep "/Applications/.*\.app/" | grep -v grep | while read -r pid command; do
      # Skip if no command string
      [[ -z "$command" ]] && continue
      
      local app_name
      app_name=$(echo "$command" | awk -F'/Contents/MacOS/' '{print $1}' | awk -F'/' '{print $NF}' | sed 's/\.app$//')
      
      local excluded=false
      for pattern in "${excluded_patterns[@]}"; do
        # Use extended regex for better pattern matching (-E)
        if echo "$command" | grep -qE "$pattern" || echo "$app_name" | grep -qE "$pattern"; then
          log "Excluding critical/specified process: $app_name (PID: $pid)"
          excluded=true
          break
        fi
      done
    
      if ! $excluded; then
        log "Attempting graceful termination (TERM signal) of $app_name (PID: $pid)"
        run_cmd kill -TERM "$pid" &>/dev/null & # Try TERM first
        app_pids+=("$pid")
      fi
  done
  
  log "Waiting 5 seconds for applications to close gracefully..."
  sleep 5
  
  log "Checking for remaining processes to force quit (KILL signal)..."
  for pid in "${app_pids[@]}"; do
    if kill -0 "$pid" &>/dev/null; then # Check if process still exists
      local remaining_app_name=$(ps -p "$pid" -o comm=)
      log "Force killing remaining process: $remaining_app_name (PID: $pid)"
      run_cmd kill -KILL "$pid" # Use KILL as last resort
    fi
  done
  success "Application termination process complete."
}


check_apns_connectivity() {
  log "Checking connectivity to Apple Push Notification Service (APNs)..."
  # Use curl with a specific path known to be responsive if available
  if curl -s --head --connect-timeout 10 "https://api.push.apple.com/3/device/0" >/dev/null 2>&1 || \
     curl -s --head --connect-timeout 10 "https://gateway.push.apple.com/" >/dev/null 2>&1; then # Fallback target
    success "APNs host is reachable."
  else
    # Give a more user-friendly error
    err "Cannot reach Apple Push Notification Services (APNs). This might be due to network restrictions (firewall, proxy). The migration wipe command relies on APNs and may fail. Please check your network connection or contact IT."
  fi
}

check_time_sync() {
  log "Checking system clock sync setting..."
  if ! systemsetup -getusingnetworktime | grep -q "On"; then
       err "Automatic time synchronization is not enabled. Please enable 'Set time and date automatically' in System Settings > General > Date & Time and rerun the migration tool."
  fi
  # Additionally, check if the time zone is set
  if ! systemsetup -gettimezone | grep -q "Time Zone:"; then
       err "System time zone is not set. Please set your time zone in System Settings > General > Date & Time and rerun the migration tool."
  fi
  success "Automatic time synchronization is enabled and time zone is set."
}

check_disk_space() {
  log "Checking available disk space..."
  local free_space_bytes
  free_space_bytes=$(df / | tail -1 | awk '{print $4 * 512}') # Get free blocks and multiply by block size (usually 512)
  local free_space_gb=$(( free_space_bytes / 1024 / 1024 / 1024 ))
  
  local required_space_gb=5 
  
  log "Available disk space: ${free_space_gb}GB"
  if [[ "$free_space_gb" -lt "$required_space_gb" ]]; then
    err "Less than ${required_space_gb} GB of free disk space available (${free_space_gb}GB found). Please free up space to continue."
  else
    success "Disk space sufficient (${free_space_gb}GB free)."
  fi
}


#
# ─── JAMF PRO API FUNCTIONS ───────────────────────────────────────────────────
#

get_jamf_auth_token() {
  log "Getting API token from origin Jamf: $origin_jamf_url"
  response=$(
    # Increased timeout for token request
    curl --connect-timeout 15 -s -X POST "$origin_jamf_url/api/v1/oauth/token" \
      -H "accept: application/json" \
      -H "content-type: application/x-www-form-urlencoded" \
      -d "grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret"
  )
  
  if [[ -z "$response" ]]; then
      err "Failed to get API token: No response from Jamf server at $origin_jamf_url. Check connection and URL."
  fi
  
  # Check if response is valid JSON before parsing
  if ! echo "$response" | jq empty; then
       err "Failed to get API token: Invalid response received from Jamf server. Response: $response"
  fi
  
  bearer_token=$(echo "$response" | jq -r '.access_token')
  
  if [[ -z "$bearer_token" || "$bearer_token" == "null" ]]; then
      local error_details=$(echo "$response" | jq -r '.') 
      err "Failed to get API token from Jamf Pro. Check credentials and API role permissions. Details: $error_details"
  fi
  
  success "API token obtained successfully."
}

get_computer_inventory_id() {
    log "Looking up device by serial: '$serial'"
    local filter="hardware.serialNumber==\"$serial\""
    local filter_encoded
    filter_encoded=$(urlencode "$filter")

    response=$(curl --connect-timeout 15 -s -w "\nHTTP_STATUS:%{http_code}" \
        -H "Authorization: Bearer $bearer_token" \
        "$origin_jamf_url/api/v1/computers-inventory?section=GENERAL&filter=${filter_encoded}")
    
    http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
    response_body=$(echo "$response" | sed '$d')

    if [[ "$http_status" -ne 200 ]]; then
        err "Jamf API request failed (HTTP $http_status) when looking up device. Check API permissions and network. Response: $response_body"
    fi
    
    if ! echo "$response_body" | jq empty; then
        err "Invalid JSON response received when looking up device. Response: $response_body"
    fi
    
    local result_count=$(echo "$response_body" | jq -r '.totalCount // 0')
    if [[ "$result_count" -eq 0 ]]; then
        err "Device with serial number '$serial' not found in the origin Jamf Pro instance ($origin_jamf_url)."
    fi

    computer_id=$(echo "$response_body" | jq -r '.results[0].id')
    management_id=$(echo "$response_body" | jq -r '.results[0].general.managementId')
    
    [[ -z "$computer_id" || "$computer_id" == "null" ]] && err "Computer ID not found in Jamf Pro API response (Serial: $serial)."
    [[ -z "$management_id" || "$management_id" == "null" ]] && err "Management ID not found in Jamf Pro API response (Serial: $serial)."

    success "Found Computer ID: $computer_id and Management ID: $management_id"
}

clear_failed_commands() {
  log "Attempting to clear failed/pending commands in Jamf Pro for Computer ID: $computer_id..."
  local payload='{"statuses": ["FAILED", "PENDING"]}'
  
  response=$(curl --connect-timeout 15 -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
    "$origin_jamf_url/api/v1/computers-inventory/$computer_id/commands/flush" \
    -H "Authorization: Bearer $bearer_token" \
    -H "Content-Type: application/json" \
    -d "$payload")

  http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
  response_body=$(echo "$response" | sed '$d')
  
  if [[ "$http_status" -ge 200 && "$http_status" -lt 300 ]]; then
    success "Successfully cleared failed/pending commands (HTTP $http_status)."
  else
    # Log detailed error but continue
    log "WARN: Could not clear failed commands (HTTP $http_status). This is non-critical, proceeding anyway. Response: $response_body"
  fi
}

trigger_remote_wipe() {
    log "Initiating remote wipe ('Erase All Content and Settings') via Jamf Pro API v2..."
    
    if $dry_run; then
        log "[DRY-RUN] Would have sent 'Erase All Content and Settings' command for management ID $management_id."
        success "[DRY-RUN] Remote wipe would have been initiated."
        return
    fi
    
    # Display the final info dialog *before* sending the command, as the Mac might restart quickly
    show_dialog_info "Wipe Command Sent" "The 'Erase All Content and Settings' command has been sent to this Mac. It will restart to the setup screen shortly. This window will close automatically." &

    # Give the dialog a moment to appear
    sleep 2
    
    # Payload for /v2/mdm/commands using "Default" obliteration behavior
    local payload
    payload=$(printf '{
      "commandData": {
        "commandType": "ERASE_DEVICE",
        "obliterationBehavior": "Default",
        "pin": "123456" 
      },
      "clientData": [{"managementId": "%s"}]
    }' "$management_id")

    # The correct endpoint for this command
    response=$(curl --connect-timeout 20 -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
        "$origin_jamf_url/api/v2/mdm/commands" \
        -H "Authorization: Bearer $bearer_token" \
        -H "Content-Type: application/json" \
        -d "$payload")

    http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
    response_body=$(echo "$response" | sed '$d')
    
    # Check for success (2xx range)
    if [[ "$http_status" -ge 200 && "$http_status" -lt 300 ]]; then
        success "EraseDevice command sent successfully (HTTP $http_status). The device should begin erasing shortly."
        # It's crucial to exit cleanly here so Jamf doesn't report a script failure
        exit 0
    else
        # Provide more detailed error logging, kill the info dialog if it's still there
        pkill -f "$DIALOG_BINARY" # Kill the info dialog on error
        err "Failed to send EraseDevice command (HTTP $http_status). Please contact IT Support. Response: $response_body"
    fi
}


#
# ─── MAIN EXECUTION ───────────────────────────────────────────────────────────
#

main() {
  # Run initial setup and hardware check immediately
  setup_environment
  check_hardware_support 
  
  # Handle deferral logic
  check_deferral
  
  # Show interactive requirements checklist
  show_requirements_dialog

  # --- Run remaining preflight checks ---
  log "Proceeding with automated preflight checks..."
  check_os_version
  check_disk_space 
  check_device_power_type # Still needed to fail early if not plugged in
  get_connection_type
  check_time_sync # Check setting, not offset
  check_onedrive_status # Check installation
  check_apns_connectivity
  check_jamf_enrollment
  check_mdm_profile
  
  log "All automated preflight checks passed."

  # --- Get Jamf Info & Clear Commands ---
  log "Connecting to Jamf Pro API..."
  get_jamf_auth_token
  get_computer_inventory_id
  clear_failed_commands

  # --- Final User Confirmation & App Kill ---
  log "Displaying final confirmation dialog..."
  if ! show_dialog_confirm "Final Confirmation - Wipe Device?" "All checks passed. All applications (except critical system services) will now be closed and the device will be wiped using 'Erase All Content and Settings'.\n\n**THIS IS YOUR LAST CHANCE TO CANCEL.**" "Wipe Mac Now" "Cancel"; then
      log "User cancelled at the final confirmation stage."
      exit 0
  fi
  
  log "User confirmed wipe. Proceeding to kill applications..."
  kill_user_apps

  # --- Execute Wipe ---
  log "Executing wipe command..."
  if $dry_run; then
    success "[DRY-RUN] Migration would have proceeded. Device wipe command not sent."
    show_dialog_info "Dry-Run Complete" "All checks passed successfully. In a real run, the wipe command would have been sent."
  else
    trigger_remote_wipe
  fi
  
  # Should not be reached in a normal run if wipe is successful (script exits in trigger_remote_wipe)
  log "Script finished (or wipe command failed before exit)." 
  exit 0 # Ensure clean exit if dry run or if trigger_remote_wipe somehow returns
}

# Ensure script is run as root
if [[ $EUID -ne 0 ]]; then
   # Log to system log if possible, as user log might not be writable yet
   syslog -s -k Facility com.apple.console Level Error Sender "$0" Message "ERROR: This script must be run as root (e.g., via Jamf Pro policy)."
   echo "ERROR: This script must be run as root."
   exit 1
fi

# Kick off the main function, passing any original script arguments along
main "$@"

