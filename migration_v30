#!/bin/zsh

#
# ─── SCRIPT CONFIGURATION ─────────────────────────────────────────────────────
#

# --- Deferral Settings ---
MAX_DEFERRALS=5
LOGGED_IN_USER=$(scutil <<< "show State:/Users/ConsoleUser" | awk '/Name :/ && ! /loginwindow/ { print $3 }')
# Deferral files now live in the user's Library
PLIST_PATH="/Users/$LOGGED_IN_USER/Library/Application Support/LBG/com.lbg.jamf-migration.plist"
LAUNCH_AGENT_PATH="/Users/$LOGGED_IN_USER/Library/LaunchAgents/com.lbg.jamf-migration.plist"


# --- SwiftDialog & Notifier Settings ---
DIALOG_BINARY="/usr/local/bin/dialog"
NOTIFIER_APP_PATH="/Applications/IBM Notifier.app" # Path to the .app
NOTIFIER_BINARY="$NOTIFIER_APP_PATH/Contents/MacOS/IBM Notifier" # Path to the executable
BRANDING_ICON="/Users/Shared/LBG_Branding_Cancara/lbg_primary_logo.png" 

# --- Jamf API Credentials & Endpoints ---
JAMF_CLIENT_ID="${4:-$JAMF_CLIENT_ID}"
JAMF_CLIENT_SECRET="${5:-$JAMF_CLIENT_SECRET}"
ORIGIN_JAMF_URL="${6:-$ORIGIN_JAMF_URL}"
TARGET_JAMF_URL="${7:-$TARGET_JAMF_URL}"
DRY_RUN="${8:-${DRY_RUN:-false}}"
JAMF_POLICY_ID="${9:-$JAMF_POLICY_ID}" # e.g., "123"

# --- Global Variables ---
management_id=""
computer_id=""

#
# ─── LOGGING AND UTILITIES ────────────────────────────────────────────────────
#

LOG_FILE="/Users/$LOGGED_IN_USER/jamf_migration_preflight.log"
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'; NC='\033[0m'

log() {
  printf '%b[%s] [INFO]  %s%b\n' \
    "$YELLOW" "$(date '+%Y-%m-%dT%H:%M:%S')" "$1" "$NC" | tee -a "$LOG_FILE"
}

success() {
  printf '%b[%s] [SUCCESS] %s%b\n' \
    "$GREEN" "$(date '+%Y-%m-%dT%H:%M:%S')" "$1" "$NC" | tee -a "$LOG_FILE"
}

# Updated err function to take $1=function_name and $2=message
err() {
  local function_name="$1"
  local message="$2"
  printf '%b[%s] [ERROR] [%s] %s%b\n' \
    "$RED" "$(date '+%Y-%m-%dT%H:%M:%S')" "$function_name" "$message" "$NC" | tee -a "$LOG_FILE" >&2
  # Only show dialog if swiftDialog is available
  if [ -x "$DIALOG_BINARY" ]; then
    "$DIALOG_BINARY" --title "Migration Error" --message "An error occurred in $function_name:\n\n$message" \
      --icon "SF=xmark.octagon.fill,colour=red" \
      --button1text "Close" --width 450 --height 250 --messagefont "size=12"
  fi
  exit 1
}

run_cmd() {
  if $dry_run && [[ "$1" == "kill" ]]; then
    log "[DRY-RUN] Would execute: $*"
  else
    "$@"
  fi
}

urlencode() {
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * )               printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "${encoded}"
}


#
# ─── SWIFTDIALOG FUNCTIONS ────────────────────────────────────────────────────
#

# These dialogs are simple and work, so we keep swiftDialog for them.
show_dialog_error() {
  "$DIALOG_BINARY" --title "Migration Error" --message "$1" --icon "SF=xmark.octagon.fill,colour=red" \
    --button1text "Close" --width 450 --height 250 --messagefont "size=12"
}

show_dialog_info() {
    "$DIALOG_BINARY" --title "$1" --message "$2" --icon "$BRANDING_ICON" \
      --button1text "OK" --width 450 --height 250 --messagefont "size=12"
}

show_dialog_confirm() {
    "$DIALOG_BINARY" --title "$1" --message "$2" --icon "$BRANDING_ICON" \
      --button1text "${3:-Proceed}" --button2text "${4:-Cancel}" --width 550 --height 350 --messagefont "size=12"
    return $?
}


#
# ─── DEFERRAL & SCHEDULING FUNCTIONS ──────────────────────────────────────────
#

schedule_relaunch() {
    local hour=$1
    local minute=$2
    
    log "Scheduling relaunch for Hour: $hour, Minute: $minute"
    
    # Ensure the user's LaunchAgents directory exists
    mkdir -p "$(dirname "$LAUNCH_AGENT_PATH")"
    
    # Unload any existing agent to ensure we are setting a new schedule
    if [ -f "$LAUNCH_AGENT_PATH" ]; then
        launchctl bootout "gui/$(id -u "$LOGGED_IN_USER")" "$LAUNCH_AGENT_PATH" &>/dev/null
    fi

    # Create the launch agent plist
    # This will run the Jamf Policy by its ID, which is the robust method.
    cat << EOF > "$LAUNCH_AGENT_PATH"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.lbg.jamf-migration</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/local/bin/jamf</string>
        <string>policy</string>
        <string>-id</string>
        <string>$JAMF_POLICY_ID</string>
    </array>
    <key>StartCalendarInterval</key>
    <dict>
        <key>Hour</key>
        <integer>$hour</integer>
        <key>Minute</key>
        <integer>$minute</integer>
    </dict>
    <key>RunAtLoad</key>
    <false/>
</dict>
</plist>
EOF

    # Set correct ownership for the user
    chown "$LOGGED_IN_USER" "$LAUNCH_AGENT_PATH"
    chmod 644 "$LAUNCH_AGENT_PATH"

    # Load the new agent as the user
    launchctl bootstrap "gui/$(id -u "$LOGGED_IN_USER")" "$LAUNCH_AGENT_PATH"
    log "Launch Agent loaded and scheduled to run policy $JAMF_POLICY_ID."
}

remove_relaunch_agent() {
    if [ -f "$LAUNCH_AGENT_PATH" ]; then
        log "Removing relaunch agent."
        launchctl bootout "gui/$(id -u "$LOGGED_IN_USER")" "$LAUNCH_AGENT_PATH" &>/dev/null
        rm "$LAUNCH_AGENT_PATH"
    fi
}

handle_deferral() {
    deferral_count=$((deferral_count + 1))
    defaults write "$PLIST_PATH" DeferralCount -int "$deferral_count"
    log "User deferred. New count: $deferral_count."

    local future_hour future_minute friendly_time
    local current_hour
    current_hour=$(date +%H)
    
    # ---
    # --- NEW SOLUTION using IBM Notifier ---
    # ---
    # This avoids all swiftDialog quoting issues by using
    # IBM Notifier's JSON-based dropdown.

    # 1. Define the options in a zsh array.
    local -a defer_options=(
        "Start of Day (9am)"
        "Lunch (12pm)"
        "End of Day (5pm)"
        "1 hour"
        "2 hours"
        "4 hours"
    )

    # 2. Build the JSON payload for the dropdown.
    #    We use jq to safely build the JSON string.
    local json_payload
    json_payload=$(jq -n --argjson options "$(printf '%s\n' "${defer_options[@]}" | jq -R . | jq -s .)" \
                   '{ "options": $options, "default_selection": "1 hour" }')
    
    if [[ -z "$json_payload" ]]; then
        err "handle_deferral" "Failed to create JSON payload for IBM Notifier."
    fi

    # 3. Build the IBM Notifier command as a zsh array
    local -a notifier_cmd=(
        "$NOTIFIER_BINARY"
        -type "popup"
        -title "Choose Deferral Time"
        -subtitle "When should we remind you? This prompt will reappear at the time you select."
        -icon_path "$BRANDING_ICON"
        -accessory_view_type "dropdown"
        -accessory_view_payload "$json_payload"
        -button_1_text "Confirm Deferral"
        -button_2_text "Cancel"
        -position "center"
        -always_on_top
    )
    
    # 4. Execute the command and capture the JSON output.
    local notifier_output
    notifier_output=$("${notifier_cmd[@]}")
    local exit_code=$?

    log "DEBUG: IBM Notifier output: '$notifier_output' (Exit code: $exit_code)"

    # 5. Parse the output.
    #    Button 2 (Cancel) has exit code 2.
    if [[ $exit_code -eq 2 ]]; then
        log "User cancelled deferral selection."
        # We must exit 0 because a deferral *did* happen,
        # and we don't want the script to continue to the wipe.
        exit 0
    fi
    
    #    Button 1 (Confirm) has exit code 0.
    #    We parse the selected option from the JSON.
    local defer_choice
    defer_choice=$(echo "$notifier_output" | jq -r .selected_option)

    if [[ -z "$defer_choice" || "$defer_choice" == "null" ]]; then
        log "ERROR: Could not parse deferral choice from IBM Notifier. Defaulting to 1 hour."
        defer_choice="1 hour"
    fi

    log "User selected deferral choice: '$defer_choice'"
    
    # 6. The case statement logic remains identical.
    case "$defer_choice" in
        'Start of Day (9am)')
            future_hour=9
            future_minute=0
            if [[ "$current_hour" -lt 9 ]]; then
                friendly_time="today at 9:00 AM"
            else
                friendly_time=$(date -v+1d +"tomorrow at 9:00 AM")
            fi
            log "User chose to defer until 9 AM."
            ;;
        'Lunch (12pm)')
            future_hour=12
            future_minute=0
            if [[ "$current_hour" -lt 12 ]]; then
                friendly_time="today at 12:00 PM"
            else
                friendly_time=$(date -v+1d +"tomorrow at 12:00 PM")
            fi
            log "User chose to defer until 12 PM."
            ;;
        'End of Day (5pm)')
            future_hour=17
            future_minute=0
            if [[ "$current_hour" -lt 17 ]]; then
                friendly_time="today at 5:00 PM"
            else
                friendly_time=$(date -v+1d +"tomorrow at 5:00 PM")
            fi
            log "User chose to defer until 5 PM."
            ;;
        '1 hour')
            future_hour=$(date -v+1H +%H)
            future_minute=$(date -v+1H +%M)
            friendly_time=$(date -v+1H +"today at %-I:%M %p")
            log "User chose to defer for 1 hour."
            ;;
        '2 hours')
            future_hour=$(date -v+2H +%H)
            future_minute=$(date -v+2H +%M)
            friendly_time=$(date -v+2H +"today at %-I:%M %p")
            log "User chose to defer for 2 hours."
            ;;
        '4 hours')
            future_hour=$(date -v+4H +%H)
            future_minute=$(date -v+4H +%M)
            friendly_time=$(date -v+4H +"today at %-I:%M %p")
            log "User chose to defer for 4 hours."
            ;;
        *)
            # This is our fallback
            log "ERROR: Deferral choice '$defer_choice' (Exit: $exit_code) did not match. Defaulting to 1 hour."
            future_hour=$(date -v+1H +%H)
            future_minute=$(date -v+1H +%M)
            friendly_time=$(date -v+1H +"today at %-I:%M %p")
            ;;
    esac

    schedule_relaunch "$future_hour" "$future_minute"
    
    # Show final confirmation
    show_dialog_info "Migration Deferred" "The migration has been deferred. You will be reminded $friendly_time."
    
    # Exit after deferral is set
    exit 0
}


check_deferral() {
  # Ensure the directory for the plist exists
  mkdir -p "$(dirname "$PLIST_PATH")"
  chown "$LOGGED_IN_USER" "$(dirname "$PLIST_PATH")"
  
  if [ ! -f "$PLIST_PATH" ]; then
    log "Plist not found. Creating with 0 deferrals."
    defaults write "$PLIST_PATH" DeferralCount -int 0
    chown "$LOGGED_IN_USER" "$PLIST_PATH"
  fi
  
  deferral_count=$(defaults read "$PLIST_PATH" DeferralCount 2>/dev/null || echo 0)
  remaining_deferrals=$((MAX_DEFERRALS - deferral_count))

  log "Deferral count: $deferral_count. Remaining: $remaining_deferrals."

  if [ "$remaining_deferrals" -le 0 ]; then
    show_dialog_info "Mandatory Migration" "The migration is now mandatory and the process will begin automatically."
    remove_relaunch_agent # Clean up scheduler as it's no longer needed
  else
    if show_dialog_confirm "StratMac to LBG Business Migration" "This Mac is now due to migrate over to new LBG Business build for Apple Mac devices.\n\n The entire process will take roughly 1 hour depending on your internet speed.\n\n You have $remaining_deferrals deferrals remaining." "Migrate Now" "Defer"; then
        log "User chose to migrate."
        remove_relaunch_agent # Clean up scheduler
    else
        handle_deferral
    fi
  fi
}

show_requirements_dialog() {
    local message
    message="To ensure a smooth migration to LBG Business, please verify the following requirements before you continue:\n\n"
    message+="* **Power:** Your Mac must be connected to a power adapter.\n"
    message+="* **Internet:** A stable internet connection is required.\n\n"
    message+="This process will close all open applications and then completely wipe all data from this Mac. Ensure your data is backed up before proceeding."

    if ! show_dialog_confirm "Migration Requirements" "$message" "I Understand, Continue" "Cancel"; then
        log "User cancelled at the requirements screen."
        exit 0
    fi
}

show_data_backup_dialog() {
    local message
    message="**FINAL DATA WARNING**\n\nThis process will **PERMANENTLY ERASE** all data on this Mac.
    \n\n- All applications, files, and settings will be deleted.
    - The Mac will be reset to factory settings.
    \n\nBefore proceeding, you **MUST** ensure all important files (documents, pictures, notes, etc.) are saved and fully synced to **OneDrive**.
    \n\n**Data not saved to OneDrive will be lost forever.**"

    if ! show_dialog_confirm "Data Deletion Confirmation" "$message" "I Confirm My Data is Backed Up" "Cancel"; then
        log "User cancelled at the final data backup warning."
        exit 0
    fi
}


#
# ─── ENVIRONMENT & PREFLIGHT CHECKS ───────────────────────────────────────────
#

setup_environment() {
    # Validate required parameters
    local missing_params=false
    local error_msg="Missing required parameters:"

    if [ -z "$JAMF_CLIENT_ID" ]; then error_msg+="\n- JAMF_CLIENT_ID"; missing_params=true; fi
    if [ -z "$JAMF_CLIENT_SECRET" ]; then error_msg+="\n- JAMF_CLIENT_SECRET"; missing_params=true; fi
    if [ -z "$ORIGIN_JAMF_URL" ]; then error_msg+="\n- ORIGIN_JAMF_URL"; missing_params=true; fi
    if [ -z "$TARGET_JAMF_URL" ]; then error_msg+="\n- TARGET_JAMF_URL"; missing_params=true; fi
    if [ -z "$JAMF_POLICY_ID" ]; then error_msg+="\n- JAMF_POLICY_ID (e.g., 123)"; missing_params=true; fi

    if $missing_params; then
      err "setup_environment" "$error_msg"
    fi

    # --- Install JQ (if missing) ---
    # This must be installed *before* we check for it
    if ! command -v jq &> /dev/null; then
        log "jq not found. Downloading for Apple Silicon..."
        # We know this is Apple Silicon because check_hardware_support() ran first in main()
        curl -L -s "https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-macos-arm64" -o "/usr/local/bin/jq"
        if [[ $? -ne 0 ]]; then
            err "setup_environment" "Failed to download jq. This is required for deferrals."
        fi
        chmod +x "/usr/local/bin/jq"
        log "jq installed successfully."
    else
        log "jq is already installed."
    fi

    # --- Install IBM Notifier (if missing) ---
    # This must be installed *before* we check for it
    if [ ! -d "$NOTIFIER_APP_PATH" ]; then
        log "IBM Notifier not found. Downloading..."
        local notifier_pkg="/tmp/IBM-Notifier.pkg"
        # Use -L to follow redirects, -s for silent, -o for output file
        curl -L -s "https://github.com/ibm/mac-ibm-notifications/releases/latest/download/IBM-Notifier.pkg" -o "$notifier_pkg"
        if [[ $? -ne 0 ]]; then
            err "setup_environment" "Failed to download IBM Notifier package."
        fi
        
        log "Installing IBM Notifier..."
        installer -pkg "$notifier_pkg" -target /
        if [[ $? -ne 0 ]]; then
            err "setup_environment" "Failed to install IBM Notifier. This is required for deferrals."
        fi
        rm "$notifier_pkg"
        log "IBM Notifier installed successfully."
    else
        log "IBM Notifier is already installed."
    fi


    # Check for all our required binaries (now as verification)
    if [ ! -x "$DIALOG_BINARY" ]; then
        # This is a fatal error, but we can't show a dialog if dialog isn't there.
        # Log to stderr, which Jamf will pick up.
        echo "FATAL: swiftDialog not found at $DIALOG_BINARY. This is required." >&2
        exit 1
    fi
    if [ ! -x "$NOTIFIER_BINARY" ]; then
        err "setup_environment" "IBM Notifier verification failed. Binary not found at '$NOTIFIER_BINARY'."
    fi
    if ! command -v jq &> /dev/null; then
        err "setup_environment" "jq verification failed. This is required for deferrals."
    fi


    client_id="$JAMF_CLIENT_ID"
    client_secret="$JAMF_CLIENT_SECRET"
    origin_jamf_url="${ORIGIN_JAMF_URL%/}"
    target_jamf_url="${TARGET_JAMF_URL%/}"
    dry_run=$(echo "$DRY_RUN" | tr '[:upper:]' '[:lower:]')
    [[ "$dry_run" == "true" ]] && dry_run=true || dry_run=false

    log_dir=$(dirname "$LOG_FILE")
    mkdir -p "$log_dir" 2>/dev/null
    chown "$LOGGED_IN_USER" "$log_dir"
    touch "$LOG_FILE" 2>/dev/null
    chown "$LOGGED_IN_USER" "$LOG_FILE"
    
    serial=$(system_profiler SPHardwareDataType | awk '/Serial/ {print $4}')
    [ -z "$serial" ] && err "setup_environment" "Could not determine serial number."
}

check_hardware_support() {
    log "Checking hardware for Apple Silicon..."
    if ! sysctl -n machdep.cpu.brand_string | grep -q "Apple"; then
        err "check_hardware_support" "This device is not an Apple Silicon Mac and is no longer supported. Please follow the process to order a new device."
    fi
    success "Apple Silicon Mac detected. Device is supported."
}

check_os_version() {
    log "Checking macOS version for local erase eligibility..."
    OS_VERSION=$(sw_vers -productVersion)
    local os_major_version
    os_major_version=$(echo "$OS_VERSION" | awk -F. '{print $1}')

    if [[ "$os_major_version" -lt 12 ]]; then
        err "check_os_version" "macOS version ($OS_VERSION) is older than macOS 12. Local 'Erase All Content and Settings' is not supported."
    else
        success "macOS version ($OS_VERSION) supports local erase."
    fi
}

get_connection_type() {
  log "Determining active network service…"
  if ! curl -s --head --connect-timeout 5 "https://www.google.co.uk/" >/dev/null 2>&1; then
    err "get_connection_type" "No internet connectivity detected. Migration requires an active internet connection."
  fi
  success "Internet connectivity check passed."
}

check_device_power_type() {
  log "Checking power source..."
  if ! pmset -g batt | grep -q "AC Power"; then
    err "check_device_power_type" "Device is not connected to AC power. Please connect your power adapter to continue."
  fi
  success "Device is connected to AC power."
}

check_mdm_profile() {
  log "Checking for active MDM profile..."
  if ! profiles status -type enrollment | grep -q "Enrolled via DEP:"; then
    err "check_mdm_profile" "No active MDM profile was detected. This device must be enrolled in MDM to proceed."
  fi
  success "Active MDM profile detected."
}

check_jamf_enrollment() {
  log "Verifying current Jamf Pro enrollment status..."
  if [[ ! -f "/usr/local/jamf/bin/jamf" ]]; then
    err "check_jamf_enrollment" "Jamf binary not found - device not enrolled in any Jamf Pro instance."
  fi
  
  local current_jss_url
  current_jss_url=$(/usr/bin/defaults read /Library/Preferences/com.jamfsoftware.jamf.plist jss_url)
  
  if [[ "$current_jss_url" == "$target_jamf_url"* ]]; then
    err "check_jamf_enrollment" "Device is already enrolled in the target Jamf Pro instance. Migration unnecessary."
  elif [[ "$current_jss_url" != "$origin_jamf_url"* ]]; then
    log "WARN: Device is enrolled in neither the origin nor target Jamf instance. Current: $current_jss_url"
  else
    success "Confirmed device is enrolled in origin Jamf instance."
  fi
}

kill_user_apps() {
  # Added "Symantec" and "WSS" to the exclusion list
  local excluded_patterns=("Self Service" "Terminal" "Finder" "dialog" "jamf" "Jamf" "IBM Notifier" "Symantec" "WSS")
  log "Starting graceful application termination..."
  
  local app_pids=()
  # Using ps as the user to find their apps
  ps -ax -o pid,command | grep "/Applications/.*\.app/" | grep -v grep | while read -r pid command; do
    local app_name
    app_name=$(echo "$command" | sed -E 's|.*/Applications/([^/]+)\.app/.*|\1|')
    local excluded=false
    for pattern in "${excluded_patterns[@]}"; do
      if [[ "$app_name" == *"$pattern"* ]]; then
        excluded=true
        break
      fi
    done
    
    if ! $excluded; then
      log "Gracefully terminating $app_name (PID: $pid)"
      run_cmd osascript -e "tell application \"$app_name\" to quit" &>/dev/null &
      app_pids+=("$pid")
    fi
  done
  
  sleep 3
  for pid in "${app_pids[@]}"; do
    if kill -0 "$pid" &>/dev/null; then
      log "Force killing PID: $pid"
      run_cmd kill -9 "$pid"
    fi
  done
}

check_apns_ connectivity() {
  log "Checking connectivity to Apple Push Notification Service (APNs)..."
  if nc -z -G 3 api.push.apple.com 443; then
    success "APNs hostname (api.push.apple.com) is reachable on port 443."
  else
    err "check_apns_connectivity" "Cannot reach APNs. This may be due to network restrictions or a firewall. Migration will likely fail."
  fi
}

#
# ─── JAMF PRO API FUNCTIONS ───────────────────────────────────────────────────
#

get_jamf_auth_token() {
  log "Getting API token from origin Jamf..."
  response=$(
    curl -s -X POST "$origin_jamf_url/api/v1/oauth/token" \
      -H "accept: application/json" \
      -H "content-type: application/x-www-form-urlencoded" \
      -d "grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret"
  )
  bearer_token=$(echo "$response" | jq -r '.access_token')
  [[ -z "$bearer_token" || "$bearer_token" == "null" ]] && err "get_jamf_auth_token" "Failed to get API token from Jamf Pro."
  success "API token obtained successfully."
}

get_computer_inventory_id() {
    log "Looking up device by serial: '$serial'"
    local filter="hardware.serialNumber==\"$serial\""
    local filter_encoded
    filter_encoded=$(urlencode "$filter")

    response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
        -H "Authorization: Bearer $bearer_token" \
        "$origin_jamf_url/api/v1/computers-inventory?section=GENERAL&filter=${filter_encoded}")
    
    http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
    response_body=$(echo "$response" | sed '$d')

    if [[ "$http_status" -ne 200 ]]; then
        err "get_computer_inventory_id" "Jamf API request failed with HTTP status $http_status."
    fi

    computer_id=$(echo "$response_body" | jq -r '.results[0].id')
    management_id=$(echo "$response_body" | jq -r '.results[0].general.managementId')
    
    [[ -z "$computer_id" || "$computer_id" == "null" ]] && err "get_computer_inventory_id" "Computer ID not found in Jamf Pro API response."
    [[ -z "$management_id" || "$management_id" == "null" ]] && err "get_computer_inventory_id" "Management ID not found in Jamf Pro API response."

    success "Found Computer ID: $computer_id and Management ID: $management_id"
}

clear_failed_commands() {
  log "Clearing any existing failed or pending commands in Jamf Pro..."
  local payload='{"statuses": ["FAILED", "PENDING"]}'
  
  response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
    "$origin_jamf_url/api/v1/computers-inventory/$computer_id/commands/flush" \
    -H "Authorization: Bearer $bearer_token" \
    -H "Content-Type: application/json" \
    -d "$payload")

  http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
  
  if [[ "$http_status" -ge 200 && "$http_status" -lt 300 ]]; then
    success "Successfully cleared failed/pending commands (HTTP $http_status)."
  else
    # This is not a critical failure, so just log a warning.
    log "WARN: Could not clear failed commands (HTTP $http_status). This is non-critical, proceeding anyway."
  fi
}

trigger_remote_wipe() {
    log "Initiating remote wipe via Jamf Pro API v2..."
    
    if $dry_run; then
        log "[DRY-RUN] Would have sent EraseDevice command for management ID $management_id."
        success "[DRY-RUN] Remote wipe would have been initiated."
        return
    fi
    
    show_dialog_info "Wipe Command Sent" "The remote wipe command has been sent to this Mac. It will restart and erase itself shortly."
    
    # This payload is structured for the /v2/mdm/commands endpoint
    local payload
    payload=$(printf '{
      "commandData": {
        "commandType": "ERASE_DEVICE",
        "obliterationBehavior": "Default",
        "pin": "123456"
      },
      "clientData": [{"managementId": "%s"}]
    }' "$management_id")

    # The correct endpoint for this command is /api/v2/mdm/commands
    response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
        "$origin_jamf_url/api/v2/mdm/commands" \
        -H "Authorization: Bearer $bearer_token" \
        -H "Content-Type: application/json" \
        -d "$payload")

    http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
    
    if [[ "$http_status" -ge 200 && "$http_status" -lt 300 ]]; then
        success "EraseDevice command sent successfully (HTTP $http_status)."
        exit 0
    else
        err "trigger_remote_wipe" "Failed to send EraseDevice command. HTTP status: $http_status"
    fi
}


#
# ─── MAIN EXECUTION ───────────────────────────────────────────────────────────
#

main() {
  # Hardware check MUST come first, as it determines which jq binary to download
  check_hardware_support
  
  # Setup will now install missing dependencies
  setup_environment
  
  check_deferral
  show_requirements_dialog
  show_data_backup_dialog # Added explicit data warning

  # --- Run all preflight checks ---
  check_os_version
  check_device_power_type
  get_connection_type
  check_apns_connectivity
  check_jamf_enrollment
  check_mdm_profile
  
  log "All preflight checks passed."

  # --- Get Jamf Info ---
  get_jamf_auth_token
  get_computer_inventory_id
  clear_failed_commands

  # --- Final Warning & App Kill ---
  # Using a more impactful warning dialog
  if ! "$DIALOG_BINARY" --title "⚠️ POINT OF NO RETURN" \
    --message "This is your final confirmation.

Clicking the button below will immediately:
1. Close all running applications.
2. Send the command to **permanently erase all data** from this Mac.

This action cannot be undone. Ensure your data is in OneDrive." \
    --icon "SF=exclamationmark.triangle.fill,colour=orange" \
    --button1text "I Understand, ERASE THIS MAC" \
    --button2text "Cancel" \
    --width 600 --height 350 --messagefont "size=14"; then
      log "User cancelled at final warning."
      exit 0
  fi
  
  kill_user_apps

  # --- Execute Wipe ---
  if $dry_run; then
    success "[DRY-RUN] Migration would have proceeded. Device wipe command not sent."
    show_dialog_info "Dry-Run Complete" "All checks passed successfully. In a real run, the wipe command would have been sent."
  else
    trigger_remote_wipe
  fi
}

main "$@"
