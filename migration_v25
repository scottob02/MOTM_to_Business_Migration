#!/bin/zsh

#
# ─── SCRIPT CONFIGURATION ─────────────────────────────────────────────────────
#

# --- Deferral Settings ---
MAX_DEFERRALS=5
PLIST_PATH="/Library/Application Support/LBG/com.lbg.jamf-migration.plist"
LOGGED_IN_USER=$(scutil <<< "show State:/Users/ConsoleUser" | awk '/Name :/ && ! /loginwindow/ { print $3 }')
# Ensure LOGGED_IN_USER is not empty
if [[ -z "$LOGGED_IN_USER" || "$LOGGED_IN_USER" == "loginwindow" ]]; then
    echo "ERROR: Could not determine logged-in user."
    # Use osascript for a basic alert if dialog isn't available early
    osascript -e 'display alert "Migration Error" message "Could not determine logged-in user. Please contact IT support." as critical'
    exit 1
fi
USER_UID=$(id -u "$LOGGED_IN_USER")
LAUNCH_AGENT_PATH="/Users/$LOGGED_IN_USER/Library/LaunchAgents/com.lbg.jamf-migration.plist"


# --- SwiftDialog Settings ---
DIALOG_BINARY="/usr/local/bin/dialog"
# This should point to the icon in your local branding package
BRANDING_ICON="/Users/Shared/LBG_Branding_Cancara/lbg_primary_logo.png" 

# --- Jamf API Credentials & Endpoints ---
JAMF_CLIENT_ID="${4:-$JAMF_CLIENT_ID}"
JAMF_CLIENT_SECRET="${5:-$JAMF_CLIENT_SECRET}"
ORIGIN_JAMF_URL="${6:-$ORIGIN_JAMF_URL}"
TARGET_JAMF_URL="${7:-$TARGET_JAMF_URL}"
DRY_RUN="${8:-${DRY_RUN:-false}}"

# --- Global Variables ---
management_id=""
computer_id=""

#
# ─── LOGGING AND UTILITIES ────────────────────────────────────────────────────
#

LOG_FILE="/Users/$LOGGED_IN_USER/jamf_migration_preflight.log"
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'; NC='\033[0m'

# Ensure log directory exists and is writable by the user
log_dir=$(dirname "$LOG_FILE")
mkdir -p "$log_dir" 2>/dev/null
chown "$LOGGED_IN_USER" "$log_dir" # Ensure user owns the log directory

# Check write permissions for log file/directory right at the start
if ! touch "$LOG_FILE" 2>/dev/null; then
    echo "ERROR: Cannot write to log file $LOG_FILE. Check permissions for user $LOGGED_IN_USER in $log_dir"
    osascript -e 'display alert "Migration Error" message "Cannot write log file. Please contact IT support." as critical'
    exit 1; 
fi
chown "$LOGGED_IN_USER" "$LOG_FILE" # Ensure user owns the log file

log() {
  # Ensure log function can write, redirect errors to stderr
  printf '%b[%s] [INFO]  %s%b\n' \
    "$YELLOW" "$(date '+%Y-%m-%dT%H:%M:%S')" "$1" "$NC" | tee -a "$LOG_FILE" 2>/dev/null || echo "ERROR: Failed writing INFO to log $LOG_FILE" >&2
}

success() {
  printf '%b[%s] [SUCCESS] %s%b\n' \
    "$GREEN" "$(date '+%Y-%m-%dT%H:%M:%S')" "$1" "$NC" | tee -a "$LOG_FILE" 2>/dev/null || echo "ERROR: Failed writing SUCCESS to log $LOG_FILE" >&2
}

err() {
  local error_message="$1"
  # Log error first
  printf '%b[%s] [ERROR] %s%b\n' \
    "$RED" "$(date '+%Y-%m-%dT%H:%M:%S')" "$error_message" "$NC" | tee -a "$LOG_FILE" 2>/dev/null || echo "ERROR: Failed writing ERROR to log $LOG_FILE" >&2
  
  # Check if dialog binary exists before trying to show error
  if [[ -x "$DIALOG_BINARY" ]]; then
      # Avoid showing dialog if already exiting due to dialog interaction (exit codes 2, 3, 4)
      local last_exit_code=$?
      if ! [[ "$last_exit_code" =~ ^(2|3|4)$ ]]; then 
          show_dialog_error "$error_message"
      fi
  else
      # Fallback alert if dialog isn't available
      osascript -e "display alert \"Migration Error\" message \"$error_message\" as critical"
  fi
  exit 1 # Exit after logging and attempting to show error
}


run_cmd() {
  if $dry_run && [[ "$1" == "kill" ]]; then
    log "[DRY-RUN] Would execute: $*"
  else
    "$@"
  fi
}

urlencode() {
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * )               printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "${encoded}"
}


#
# ─── SWIFTDIALOG FUNCTIONS ────────────────────────────────────────────────────
#

# Check if dialog binary exists (moved check earlier)
if [[ ! -x "$DIALOG_BINARY" ]]; then
    log "CRITICAL ERROR: SwiftDialog binary not found or not executable at $DIALOG_BINARY."
    osascript -e 'display alert "Migration Error" message "SwiftDialog is required but not found. Please contact IT support." as critical'
    exit 1
fi

show_dialog_error() {
  # Run dialog as the logged-in user to ensure it appears correctly
  sudo -u "$LOGGED_IN_USER" "$DIALOG_BINARY" --title "Migration Error" --message "$1" --icon "SF=xmark.octagon.fill,colour=red" \
    --button1text "Close" --width 450 --height 250 --messagefont "size=12" --json &>/dev/null 
}

show_dialog_info() {
    sudo -u "$LOGGED_IN_USER" "$DIALOG_BINARY" --title "$1" --message "$2" --icon "$BRANDING_ICON" \
      --button1text "OK" --width 450 --height 250 --messagefont "size=12" --json &>/dev/null
}

show_dialog_confirm() {
    # Returns 0 if Button 1 pressed, 2 if Button 2 pressed
    # Run dialog as the logged-in user
    sudo -u "$LOGGED_IN_USER" "$DIALOG_BINARY" --title "$1" --message "$2" --icon "$BRANDING_ICON" \
      --button1text "${3:-Proceed}" --button2text "${4:-Cancel}" --width 550 --height 350 --messagefont "size=12" --json &>/dev/null
    return $?
}


#
# ─── DEFERRAL & SCHEDULING FUNCTIONS ──────────────────────────────────────────
#

schedule_relaunch() {
    local schedule_type="$1"
    local custom_epoch="$2" # Expecting epoch time for custom schedule

    local target_epoch
    local current_epoch=$(date +%s)

    log "Scheduling relaunch based on type: $schedule_type"

    case "$schedule_type" in
        "1hour")
            target_epoch=$((current_epoch + 3600))
            ;;
        "2hour")
            target_epoch=$((current_epoch + 7200))
            ;;
        "tomorrow9am")
             local tomorrow_date=$(date -v+1d +%Y-%m-%d)
             target_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$tomorrow_date 09:00:00" +%s 2>/dev/null)
             # Basic check if date command failed
             [[ $? -ne 0 || -z "$target_epoch" ]] && err "Failed to calculate epoch for tomorrow 9 AM."
             # Ensure it's in the future
             [[ "$target_epoch" -le "$current_epoch" ]] && target_epoch=$((target_epoch + 86400)) # Add a day if already past 9am tomorrow somehow
            ;;
        "eod") # End of Day (Today 5 PM = 17:00)
            local today_date=$(date +%Y-%m-%d)
            target_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$today_date 17:00:00" +%s 2>/dev/null)
             [[ $? -ne 0 || -z "$target_epoch" ]] && err "Failed to calculate epoch for End of Day."
            # If it's already past 5 PM today, schedule for tomorrow 5 PM
            if [[ "$current_epoch" -ge "$target_epoch" ]]; then
                log "Current time is past 5 PM, scheduling for tomorrow 5 PM."
                local tomorrow_date=$(date -v+1d +%Y-%m-%d)
                target_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$tomorrow_date 17:00:00" +%s 2>/dev/null)
                [[ $? -ne 0 || -z "$target_epoch" ]] && err "Failed to calculate epoch for tomorrow 5 PM."
            fi
            ;;
        "1day") # In 1 Day (Tomorrow at 9 AM for consistency)
            local tomorrow_date=$(date -v+1d +%Y-%m-%d)
            target_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$tomorrow_date 09:00:00" +%s 2>/dev/null)
            [[ $? -ne 0 || -z "$target_epoch" ]] && err "Failed to calculate epoch for 1 day deferral."
             # Ensure it's in the future
             [[ "$target_epoch" -le "$current_epoch" ]] && target_epoch=$((target_epoch + 86400))
           ;;
        "custom")
            if [[ -z "$custom_epoch" || ! "$custom_epoch" =~ ^[0-9]+$ ]]; then
                # Use show_dialog_error as this is a user-facing issue from handle_deferral
                log "ERROR: Invalid custom epoch time provided for scheduling: '$custom_epoch'"
                show_dialog_error "Invalid Date/Time\n\nCould not schedule the reminder. Please try selecting the date and time again."
                exit 1 # Exit here to prevent bad scheduling
            fi
            target_epoch="$custom_epoch"
            # Validation: ensure custom time is in the future
            if [[ "$target_epoch" -le "$current_epoch" ]]; then
                 log "ERROR: Custom deferral time '$custom_epoch' is in the past."
                 show_dialog_error "Invalid Date/Time\n\nThe selected time is in the past. Please choose a future time."
                 exit 1
            fi
             # Validation: ensure custom time is within 7 days
            local seven_days_later=$((current_epoch + 604800)) # 7 * 24 * 60 * 60
            if [[ "$target_epoch" -gt "$seven_days_later" ]]; then
                log "ERROR: Custom deferral time '$custom_epoch' is more than 7 days away."
                show_dialog_error "Invalid Date/Time\n\nThe selected time is more than 7 days in the future. Please choose an earlier time."
                exit 1
            fi
            ;;
        *)
            err "Invalid schedule type '$schedule_type'" # Internal error
            ;;
    esac

    # Convert target epoch back to date components for the plist
    target_year=$(date -r "$target_epoch" +%Y)
    target_month=$(date -r "$target_epoch" +%m)
    target_day=$(date -r "$target_epoch" +%d)
    target_hour=$(date -r "$target_epoch" +%H)
    target_minute=$(date -r "$target_epoch" +%M)

    log "Calculated Target - Year:$target_year, Month:$target_month, Day:$target_day, Hour:$target_hour, Minute:$target_minute"

    # Unload any existing agent (as user)
    sudo -u "$LOGGED_IN_USER" launchctl bootout "gui/$USER_UID" "$LAUNCH_AGENT_PATH" &>/dev/null

    # Create the launch agent plist
    cat << EOF > "$LAUNCH_AGENT_PATH"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.lbg.jamf-migration</string>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/zsh</string>
        <string>$0</string> <!-- Rerun this script -->
    </array>
    <key>StartCalendarInterval</key>
    <dict>
        <key>Year</key>
        <integer>$target_year</integer>
        <key>Month</key>
        <integer>$target_month</integer>
        <key>Day</key>
        <integer>$target_day</integer>
        <key>Hour</key>
        <integer>$target_hour</integer>
        <key>Minute</key>
        <integer>$target_minute</integer>
    </dict>
    <key>RunAtLoad</key>
    <false/>
</dict>
</plist>
EOF

    # Set correct ownership and permissions
    chown "$LOGGED_IN_USER" "$LAUNCH_AGENT_PATH"
    chmod 644 "$LAUNCH_AGENT_PATH"

    # Load the new agent using the correct UID (as user)
    if ! sudo -u "$LOGGED_IN_USER" launchctl bootstrap "gui/$USER_UID" "$LAUNCH_AGENT_PATH"; then
        err "Failed to load scheduled relaunch agent. Please contact IT support."
    fi
    log "Launch Agent loaded and scheduled for $target_year-$target_month-$target_day at $target_hour:$target_minute."
}


remove_relaunch_agent() {
    if [ -f "$LAUNCH_AGENT_PATH" ]; then
        log "Removing relaunch agent."
        # Run as user
        sudo -u "$LOGGED_IN_USER" launchctl bootout "gui/$USER_UID" "$LAUNCH_AGENT_PATH" &>/dev/null
        rm "$LAUNCH_AGENT_PATH"
    fi
}

handle_deferral() {
    local remaining=$((MAX_DEFERRALS - deferral_count)) # Calculate remaining for message
    log "User chose to defer. Current count: $deferral_count. Remaining: $remaining."
    
    # Use SwiftDialog dropdown for deferral options, adding 'custom'
    local defer_choice_output
    local defer_choice_exit_code
    
    # Loop to allow retrying custom date selection if it fails validation in schedule_relaunch
    while true; do
        defer_choice_output=$(sudo -u "$LOGGED_IN_USER" "$DIALOG_BINARY" --title "Choose Deferral Time" \
          --message "The migration is required soon. Please choose when you would like to be reminded next.\n\nYou have $remaining deferrals remaining." \
          --icon "$BRANDING_ICON" --width 450 --height 300 --messagefont "size=12" \
          --selecttitle "Deferral Options" --selectvalues "1hour, 2hour, tomorrow9am, eod, 1day, custom" \
          --selectvaluekey "value" --selectnamekey "name" \
          --selectoptions '[
              {"name": "Remind me in 1 Hour", "value": "1hour"},
              {"name": "Remind me in 2 Hours", "value": "2hour"},
              {"name": "Tomorrow Morning (9 AM)", "value": "tomorrow9am"},
              {"name": "End of Day (Today 5 PM)", "value": "eod"},
              {"name": "Remind me in 1 Day (Tomorrow 9 AM)", "value": "1day"},
              {"name": "Choose Specific Date/Time...", "value": "custom"}
          ]' \
          --selectdefault "1hour" \
          --selectrequired \
          --button1text "Confirm Deferral" --button2text "Cancel Migration" --json)
          
        defer_choice_exit_code=$?
        
        if [[ $defer_choice_exit_code -eq 2 ]]; then
            log "User cancelled deferral selection (chose Cancel Migration)."
            exit 0 # Exit gracefully
        elif [[ $defer_choice_exit_code -ne 0 ]]; then
            # Handle potential dialog errors (e.g., if dialog process is killed)
            err "Error displaying deferral options dialog. Exit Code: $defer_choice_exit_code"
        fi

        local selected_deferral=$(echo "$defer_choice_output" | jq -r '.SelectedOption')

        if [[ -z "$selected_deferral" || "$selected_deferral" == "null" ]]; then
             # This might happen if jq fails or response is unexpected
            log "ERROR: Could not determine selected deferral option from dialog output: $defer_choice_output"
            # Show error and loop back to deferral choice
             show_dialog_error "An error occurred selecting the deferral time. Please try again."
             continue # Retry deferral choice
        fi

        log "User selected deferral option: $selected_deferral"

        local defer_message=""
        local custom_epoch_time=""
        local schedule_result=0 # 0 for success, 1 for failure (e.g., validation failed)

        if [[ "$selected_deferral" == "custom" ]]; then
            # Show date picker dialog (run as user)
            local current_epoch=$(date +%s)
            local max_epoch=$((current_epoch + 604800)) # 7 days from now
            local min_date_iso=$(date -r $((current_epoch + 60)) '+%Y-%m-%d %H:%M') # Minimum 1 minute in future
            local max_date_iso=$(date -r "$max_epoch" '+%Y-%m-%d %H:%M')

            log "Displaying custom date/time picker (Min: $min_date_iso, Max: $max_date_iso)..."
            local datepicker_output
            local datepicker_exit_code
            datepicker_output=$(sudo -u "$LOGGED_IN_USER" "$DIALOG_BINARY" --title "Select Custom Deferral Time" \
              --message "Choose a date and time within the next 7 days." \
              --icon "$BRANDING_ICON" --width 450 --height 300 --messagefont "size=12" \
              --datepicker --dateformat "yyyy-MM-dd HH:mm" \
              --button1text "Set Time" --button2text "Cancel" --json)

            datepicker_exit_code=$?

            if [[ $datepicker_exit_code -eq 2 ]]; then
                log "User cancelled custom date/time selection."
                continue # Go back to the main deferral selection
            elif [[ $datepicker_exit_code -ne 0 ]]; then
                 log "ERROR: Error displaying date picker dialog. Exit Code: $datepicker_exit_code"
                 show_dialog_error "An error occurred displaying the date picker. Please try again or choose another deferral option."
                 continue # Go back to the main deferral selection
            fi

            local selected_date_str=$(echo "$datepicker_output" | jq -r '.SelectedDate')
            if [[ -z "$selected_date_str" || "$selected_date_str" == "null" ]]; then
                 log "ERROR: Could not get selected date/time from date picker output: $datepicker_output"
                 show_dialog_error "Could not read the selected date. Please try again."
                 continue # Go back to the main deferral selection
            fi

            log "Custom date/time string selected: $selected_date_str"
            # Convert selected date string to epoch time using macOS `date`
            custom_epoch_time=$(date -j -f "%Y-%m-%d %H:%M" "$selected_date_str" +%s 2>/dev/null)
            if [[ $? -ne 0 || -z "$custom_epoch_time" ]]; then
                log "ERROR: Invalid date/time format received from date picker or date conversion failed: $selected_date_str"
                show_dialog_error "The selected date or time format was invalid ($selected_date_str). Please try again."
                continue # Go back to the main deferral selection
            fi
            
            # Perform validation *before* calling schedule_relaunch for custom time
            current_epoch=$(date +%s)
            seven_days_later=$((current_epoch + 604800))
            if [[ "$custom_epoch_time" -le "$current_epoch" ]]; then
                log "ERROR: Custom deferral time '$custom_epoch_time' is in the past."
                show_dialog_error "Invalid Date/Time\n\nThe selected time is in the past. Please choose a future time."
                schedule_result=1 # Indicate failure
            elif [[ "$custom_epoch_time" -gt "$seven_days_later" ]]; then
                log "ERROR: Custom deferral time '$custom_epoch_time' is more than 7 days away."
                show_dialog_error "Invalid Date/Time\n\nThe selected time is more than 7 days in the future. Please choose an earlier time."
                schedule_result=1 # Indicate failure
            else
                local formatted_custom_time=$(date -r "$custom_epoch_time" '+%A, %B %d at %I:%M %p') # More readable format
                defer_message="OK. You will be reminded on $formatted_custom_time."
            fi
        else
            # Standard deferral messages
            case "$selected_deferral" in
                "1hour") defer_message="OK. You will be reminded in 1 hour." ;;
                "2hour") defer_message="OK. You will be reminded in 2 hours." ;;
                "tomorrow9am") defer_message="OK. You will be reminded tomorrow at 9 AM." ;;
                "eod") 
                    if [[ $(date +%H) -ge 17 ]]; then defer_message="OK. You will be reminded tomorrow at 5 PM."; else defer_message="OK. You will be reminded today at 5 PM."; fi ;;
                "1day") defer_message="OK. You will be reminded tomorrow at 9 AM." ;; 
            esac
        fi

        # If validation passed (or wasn't custom time), schedule and exit loop
        if [[ "$schedule_result" -eq 0 ]]; then
             # Increment actual deferral count *only* when scheduling succeeds
             defaults write "$PLIST_PATH" DeferralCount -int "$deferral_count"
             log "User deferred. New count recorded: $deferral_count."
             
            schedule_relaunch "$selected_deferral" "$custom_epoch_time" # This will err() and exit if scheduling fails internally
            show_dialog_info "Migration Deferred" "$defer_message"
            exit 0 # Exit script after successful deferral
        fi
        # If schedule_result was 1 (custom validation failed), the loop continues
        log "Custom date validation failed, looping back to deferral choice."
    done # End of while loop
}



check_deferral() {
  # Ensure the plist directory exists and has correct permissions
  local plist_dir=$(dirname "$PLIST_PATH")
  if [[ ! -d "$plist_dir" ]]; then
      mkdir -p "$plist_dir" || err "Failed to create directory $plist_dir. Check permissions."
      chmod 755 "$plist_dir" # Standard permissions for Application Support subdirs
  fi
  
  if [ ! -f "$PLIST_PATH" ]; then
    log "Deferral plist not found at '$PLIST_PATH'. Creating with 0 deferrals."
    # Write as root initially
    if ! defaults write "$PLIST_PATH" DeferralCount -int 0; then
       err "Failed to create deferral plist at '$PLIST_PATH'. Check permissions."
    fi
    # Optional: Change ownership if needed, though root access is fine for reading/writing here
    # chown root:wheel "$PLIST_PATH" # Example ownership
    chmod 644 "$PLIST_PATH"
  fi
  
  deferral_count=$(defaults read "$PLIST_PATH" DeferralCount 2>/dev/null)
   if ! [[ "$deferral_count" =~ ^[0-9]+$ ]]; then
        log "WARN: Invalid deferral count found in plist. Resetting to 0."
        defaults write "$PLIST_PATH" DeferralCount -int 0
        deferral_count=0
   fi
   
  remaining_deferrals=$((MAX_DEFERRALS - deferral_count))
  # Ensure remaining isn't negative if count somehow exceeds max
  [[ "$remaining_deferrals" -lt 0 ]] && remaining_deferrals=0 

  log "Deferral count: $deferral_count. Maximum allowed: $MAX_DEFERRALS. Remaining: $remaining_deferrals."

  if [ "$remaining_deferrals" -le 0 ]; then
    log "No deferrals remaining. Migration is mandatory."
    show_dialog_info "Mandatory Migration" "The migration is now mandatory.\nPlease save your work, the process will begin automatically after closing this window."
    remove_relaunch_agent 
  else
    # Use show_dialog_confirm (runs as user) and check its exit status
    if show_dialog_confirm "Jamf Pro Migration Required" "This Mac needs to be migrated to a new management system.\n\nPlease save your work before proceeding.\n\nYou have $remaining_deferrals deferrals remaining." "Migrate Now" "Defer"; then
        log "User chose to migrate now."
        remove_relaunch_agent 
    else
        # Exit status 2 means "Defer" was pressed
        log "User chose to defer."
        handle_deferral # Handles scheduling and exits
    fi
  fi
}

show_requirements_dialog() {
    local power_status_checked="false"
    local power_status_icon="SF=xmark.circle.fill,colour=red" 
    if pmset -g batt | grep -q "AC Power"; then
        power_status_checked="true"
        power_status_icon="SF=checkmark.circle.fill,colour=green"
    fi
    
    local dialog_output
    local dialog_exit_code

    # SwiftDialog automatically enables button 1 when all 'required' checkboxes are checked.
    # No need for a manual loop here.
    dialog_output=$(sudo -u "$LOGGED_IN_USER" "$DIALOG_BINARY" \
        --title "Migration Requirements Checklist" \
        --message "Please confirm the following before proceeding.\n**This process will wipe all data from your Mac.**" \
        --icon "$BRANDING_ICON" \
        --width 650 --height 450 --messagefont "size=12" --alignment "left" \
        --checkbox "label=**Power:** Your Mac is connected to a power adapter., checked=$power_status_checked, disabled, icon=$power_status_icon" \
        --checkbox "label=**Internet:** You have a stable internet connection., required, icon=SF=wifi" \
        --checkbox "label=**Disk Space:** You have at least 5 GB of free disk space., required, icon=SF=opticaldiscdrive" \
        --checkbox "label=**OneDrive Backup:** I confirm all important data is saved/synced to OneDrive., required, icon=SF=cloud.fill" \
        --checkbox "label=**Time Sync:** System clock is set automatically., required, icon=SF=clock.fill" \
        --button1text "Continue" \
        --button2text "Cancel" \
        --json)
        
    dialog_exit_code=$?

    log "Requirements dialog exit code: $dialog_exit_code"

    if [[ $dialog_exit_code -eq 2 ]]; then
        log "User cancelled at the requirements checklist."
        exit 0 # Exit gracefully
    elif [[ $dialog_exit_code -ne 0 ]]; then
        # This usually means the dialog was closed unexpectedly or encountered an internal error.
        err "Requirements checklist dialog failed or was closed unexpectedly. Exit Code: $dialog_exit_code"
    fi
    
    # If exit code is 0, SwiftDialog has already validated required checkboxes.
    # We still might want to log the choices for records.
     local internet_ok=$(echo "$dialog_output" | jq -r '.checkbox[1].checked // "false"') # Index 1 assuming Power is 0
     local disk_ok=$(echo "$dialog_output" | jq -r '.checkbox[2].checked // "false"')
     local backup_ok=$(echo "$dialog_output" | jq -r '.checkbox[3].checked // "false"')
     local time_ok=$(echo "$dialog_output" | jq -r '.checkbox[4].checked // "false"')
     log "Checkbox states confirmed: Internet=$internet_ok, Disk=$disk_ok, Backup=$backup_ok, Time=$time_ok"

    success "User confirmed all migration requirements."
}



#
# ─── ENVIRONMENT & PREFLIGHT CHECKS ───────────────────────────────────────────
#

setup_environment() {
    # Validate required parameters passed from Jamf Pro
    local missing_params=false
    local error_msg="Script Configuration Error: Missing required parameters:"
    log "Checking script parameters..."
    if [ -z "$JAMF_CLIENT_ID" ]; then error_msg+="\n- Jamf API Client ID (Parameter 4)"; missing_params=true; fi
    if [ -z "$JAMF_CLIENT_SECRET" ]; then error_msg+="\n- Jamf API Client Secret (Parameter 5)"; missing_params=true; fi
    if [ -z "$ORIGIN_JAMF_URL" ]; then error_msg+="\n- Origin Jamf URL (Parameter 6)"; missing_params=true; fi
    if [ -z "$TARGET_JAMF_URL" ]; then error_msg+="\n- Target Jamf URL (Parameter 7)"; missing_params=true; fi

    if $missing_params; then
      error_msg+="\n\nPlease check the script parameters in the Jamf Pro policy."
      err "$error_msg" # This will log and show dialog
    fi
    log "All required script parameters are present."

    client_id="$JAMF_CLIENT_ID"
    client_secret="$JAMF_CLIENT_SECRET"
    origin_jamf_url="${ORIGIN_JAMF_URL%/}"
    target_jamf_url="${TARGET_JAMF_URL%/}"
    dry_run=$(echo "$DRY_RUN" | tr '[:upper:]' '[:lower:]')
    [[ "$dry_run" == "true" ]] && dry_run=true || dry_run=false
    log "Dry Run mode: $dry_run"

    serial=$(system_profiler SPHardwareDataType | awk '/Serial Number/ {print $NF}') # More robust serial fetching
    [ -z "$serial" ] && err "Could not determine device serial number."
    log "Device Serial Number: $serial"
    log "Script running for user: $LOGGED_IN_USER (UID: $USER_UID)"
}

check_hardware_support() {
    log "Checking hardware for Apple Silicon..."
    # Use sysctl -n hw.optional.arm64 instead of brand string for reliability
    if ! sysctl -n hw.optional.arm64 | grep -q "1"; then
        err "This device is not an Apple Silicon Mac and is no longer supported for this migration. Please follow the process to order a new device."
    fi
    success "Apple Silicon Mac detected. Device is supported."
}

check_os_version() {
    log "Checking macOS version..."
    OS_VERSION=$(sw_vers -productVersion)
    local os_major_version=$(echo "$OS_VERSION" | awk -F. '{print $1}')

    # Erase All Content & Settings requires macOS 12 Monterey or newer
    if [[ "$os_major_version" -lt 12 ]]; then
        err "macOS version ($OS_VERSION) is older than macOS 12 (Monterey). The 'Erase All Content and Settings' feature required for this migration is not supported. Please update macOS or contact IT support."
    else
        success "macOS version ($OS_VERSION) is supported for 'Erase All Content and Settings'."
    fi
}

get_connection_type() {
  log "Checking internet connection..."
  # Check against a reliable target
  if ! curl -s --head --connect-timeout 10 "https://www.apple.com/" >/dev/null 2>&1; then
    err "No internet connectivity detected (cannot reach apple.com). A stable internet connection is required throughout the migration process."
  fi
  success "Internet connectivity check passed."
}

check_device_power_type() {
  log "Checking power source..."
  # This is a hard requirement, fail if not plugged in
  if ! pmset -g batt | grep -q "AC Power"; then
    err "Device is not connected to AC power. Please connect your power adapter and rerun the migration tool to ensure the process completes successfully."
  fi
  success "Device is connected to AC power."
}

check_mdm_profile() {
  log "Checking for active MDM profile..."
  local profile_info
  profile_info=$(profiles show -type enrollment 2>/dev/null)
  
  if [[ -z "$profile_info" ]] || ! echo "$profile_info" | grep -q "Enrolled via"; then
       # Fallback using system_profiler which is slower but sometimes more reliable
       log "profiles command failed or showed no enrollment, trying system_profiler..."
       if ! system_profiler SPConfigurationProfileDataType | grep -q "Enrollment Profile"; then
           err "No active MDM enrollment profile was detected. This device must be properly enrolled in MDM to proceed with migration."
       fi
  fi
  success "Active MDM enrollment profile detected."
}


check_jamf_enrollment() {
  log "Verifying current Jamf Pro enrollment status..."
  local jamf_binary=""
  if [[ -x "/usr/local/bin/jamf" ]]; then jamf_binary="/usr/local/bin/jamf"; 
  elif [[ -x "/usr/local/jamf/bin/jamf" ]]; then jamf_binary="/usr/local/jamf/bin/jamf"; 
  else err "Jamf binary not found or not executable. Device may not be enrolled correctly."; fi
  log "Using Jamf binary at $jamf_binary"
  
  local current_jss_url=""
  # Prefer reading plist first
  if [[ -f "/Library/Preferences/com.jamfsoftware.jamf.plist" ]]; then
      current_jss_url=$(/usr/bin/defaults read /Library/Preferences/com.jamfsoftware.jamf.plist jss_url 2>/dev/null)
  fi

  # Fallback: Ask jamf binary
  if [[ -z "$current_jss_url" ]]; then
       log "Plist method failed, trying 'jamf checkJSSConnection'..."
       current_jss_url=$(timeout 10 "$jamf_binary" checkJSSConnection -dump | awk '/url: / {print $2}')
       if [[ $? -ne 0 ]]; then log "WARN: 'jamf checkJSSConnection' timed out or failed."; fi
  fi

  if [[ -z "$current_jss_url" ]]; then
      err "Could not determine the current Jamf Pro server URL. Please ensure the device is properly enrolled."
  fi

  log "Current Jamf URL determined: $current_jss_url"
  
  local norm_current_url="${current_jss_url%/}"
  local norm_target_url="${target_jamf_url%/}"
  local norm_origin_url="${origin_jamf_url%/}"

  if [[ "$norm_current_url" == "$norm_target_url" ]]; then
    err "Device is already enrolled in the target Jamf Pro instance ($target_jamf_url). Migration is not necessary."
  elif [[ "$norm_current_url" != "$norm_origin_url" ]]; then
    err "Device is enrolled in an unexpected Jamf Pro instance ($current_jss_url). Expected origin: $origin_jamf_url. Cannot proceed."
  else
    success "Confirmed device is enrolled in the correct origin Jamf instance ($origin_jamf_url)."
  fi
}

check_onedrive_status() {
    log "Checking OneDrive installation..."
    if [[ ! -d "/Applications/OneDrive.app" ]]; then
        # This is a hard requirement for the user confirmation step to make sense
        err "OneDrive.app is not installed. Please install OneDrive and ensure your data is fully synced before attempting migration."
    fi
    success "OneDrive application is installed. User must confirm data sync."
}


kill_user_apps() {
  # Keep this list minimal but include known problematic/interfering apps if needed
  local excluded_patterns=(
      "Self Service" "Terminal" "Finder" "dialog" "[j]amf" "loginwindow" 
      "WindowServer" "SystemUIServer" "Dock" "[m]ds" "Spotlight" "NotificationCenter" 
      "Symantec" "WSSAgent" "[M]icrosoft Defender" "[M]sSense" "[w]dav" # Security/Network 
      "coreauthd" "securityd" "runningboardd" "UserEventAgent" # Core Services
      "ControlCenter" "SoftwareUpdateNotificationManager" 
      "OneDrive" # Let's keep OneDrive running
      "SecurityAgent" "universalAccessAuthWarn" 
      "kernel_task" "launchd" "distnoted" "configd" "powerd" # System Daemons
      )
  log "Starting graceful application termination (excluding critical/system processes)..."
  
  local app_pids_to_terminate=()
  # Get all PIDs for the current user
  local user_pids=$(pgrep -u "$USER_UID")

  for pid in $user_pids; do
      local command=$(ps -p "$pid" -o command= | head -n 1) # head -n 1 handles multi-line command outputs
      # Skip if no command or if it's a kernel process
      [[ -z "$command" || "$command" == *"kernel_task"* ]] && continue 
      
      # Basic check if it looks like a GUI app path
      if ! echo "$command" | grep -q "/Applications/.*\.app/"; then
          continue # Skip non-app processes
      fi
      
      local app_name=$(echo "$command" | awk -F'/Contents/MacOS/' '{print $1}' | awk -F'/' '{print $NF}' | sed 's/\.app$//')
      
      local excluded=false
      for pattern in "${excluded_patterns[@]}"; do
        # Use grep -qE for efficient regex matching
        if echo "$command" | grep -qE "$pattern" || echo "$app_name" | grep -qE "$pattern"; then
          # log "Excluding process: $app_name (PID: $pid)" # Debug logging if needed
          excluded=true
          break
        fi
      done
    
      if ! $excluded; then
        log "Adding to termination list: $app_name (PID: $pid)"
        app_pids_to_terminate+=("$pid")
      fi
  done

  if [[ ${#app_pids_to_terminate[@]} -gt 0 ]]; then
      log "Attempting graceful termination (TERM signal) for ${#app_pids_to_terminate[@]} application(s)..."
      # Send TERM signal to all identified PIDs at once
      kill -TERM "${app_pids_to_terminate[@]}" &>/dev/null
      
      log "Waiting 5 seconds for applications to close gracefully..."
      sleep 5
      
      log "Checking for remaining processes to force quit (KILL signal)..."
      local still_running_count=0
      for pid in "${app_pids_to_terminate[@]}"; do
        if kill -0 "$pid" &>/dev/null; then # Check if process still exists
          local remaining_app_name=$(ps -p "$pid" -o comm=)
          log "Force killing remaining process: $remaining_app_name (PID: $pid)"
          kill -KILL "$pid" # Use KILL as last resort
          still_running_count=$((still_running_count + 1))
        fi
      done
      [[ "$still_running_count" -gt 0 ]] && log "$still_running_count process(es) required force quitting." || log "All targeted applications closed gracefully."
  else
       log "No user applications found needing termination (besides excluded ones)."
  fi
  success "Application termination process complete."
}


check_apns_connectivity() {
  log "Checking connectivity to Apple Push Notification Service (APNs)..."
  # Attempt connection directly to the gateway host
  if nc -z -w 10 gateway.push.apple.com 5223 &>/dev/null; then 
    success "APNs host (gateway.push.apple.com:5223) is reachable."
  else
    log "WARN: Could not reach APNs on port 5223. Trying port 443 as fallback..."
     if curl -s --head --connect-timeout 10 "https://api.push.apple.com/" >/dev/null 2>&1; then
          success "APNs host (api.push.apple.com:443) is reachable."
     else
          # Make this a warning, not a failure, as wipe command might still queue
          log "WARN: Cannot reach Apple Push Notification Services (APNs) on standard ports (5223, 443). This might be due to network restrictions (firewall, proxy). The wipe command might be delayed until connectivity is restored."
          # Optionally show a dialog warning
          # show_dialog_info "APNs Connectivity Issue" "Could not connect to Apple Push Notification Services. The wipe command might be delayed. Please ensure you remain connected to the network."
     fi
  fi
}

check_time_sync() {
  log "Checking system clock sync setting..."
  if ! systemsetup -getusingnetworktime | grep -q "On"; then
       # Make this a warning and prompt user? Or hard fail? Let's hard fail for now.
       err "Automatic time synchronization is not enabled. Please enable 'Set time and date automatically' in System Settings > General > Date & Time and rerun the migration tool. Accurate time is crucial for security and enrollment."
  fi
  # Check time zone setting
  if ! systemsetup -gettimezone | grep -q "Time Zone:"; then
       err "System time zone is not set. Please set your time zone in System Settings > General > Date & Time and rerun the migration tool."
  fi
  # Optional: Check actual offset if possible, but treat as warning
  local offset=$(sntp time.apple.com 2>/dev/null | awk '/^[+-]?[0-9]+\.[0-9]+/ {print $1}')
  if [[ -n "$offset" ]]; then
      local drift_abs=$(printf "%.0f" "$(echo "$offset" | tr -d '+-')")
      if [[ "$drift_abs" -gt 180 ]]; then
           log "WARN: System time offset from Apple NTP is significant (${offset}s), but automatic sync is enabled. Proceeding with caution."
      else
           log "System time offset check passed (Drift: ${offset}s)."
      fi
  else
      log "WARN: Could not verify time offset against NTP server (network issue?). Proceeding as automatic sync is enabled."
  fi
  success "Automatic time synchronization is enabled and time zone is set."
}

check_disk_space() {
  log "Checking available disk space..."
  local free_space_bytes
  # Use POSIX standard command for potentially better compatibility
  free_space_bytes=$(df -k / | tail -1 | awk '{print $4 * 1024}') 
  local free_space_gb=$(( free_space_bytes / 1024 / 1024 / 1024 ))
  
  local required_space_gb=5 
  
  log "Available disk space: ${free_space_gb}GB"
  if [[ "$free_space_gb" -lt "$required_space_gb" ]]; then
    err "Less than ${required_space_gb} GB of free disk space available (${free_space_gb}GB found). Please free up space before proceeding with the migration."
  else
    success "Disk space sufficient (${free_space_gb}GB free)."
  fi
}


#
# ─── JAMF PRO API FUNCTIONS ───────────────────────────────────────────────────
#

get_jamf_auth_token() {
  log "Getting API token from origin Jamf: $origin_jamf_url"
  response=$(
    curl --connect-timeout 15 -s -L -X POST "$origin_jamf_url/api/v1/oauth/token" \
      -H "accept: application/json" \
      -H "content-type: application/x-www-form-urlencoded" \
      -d "grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret"
  )
  local curl_exit_code=$?
  if [[ $curl_exit_code -ne 0 ]]; then
       err "Failed to connect to Jamf Pro token endpoint ($origin_jamf_url). cURL error code: $curl_exit_code. Check network connection and URL."
  fi
  if [[ -z "$response" ]]; then err "Failed to get API token: No response received from Jamf server."; fi
  if ! echo "$response" | jq empty; then err "Failed to get API token: Invalid JSON response received. Response: $response"; fi
  
  bearer_token=$(echo "$response" | jq -r '.access_token')
  
  if [[ -z "$bearer_token" || "$bearer_token" == "null" ]]; then
      local error_details=$(echo "$response" | jq -r '.') 
      err "Failed to get API token from Jamf Pro. Verify API Client ID, Secret, and Role Permissions. Server Response: $error_details"
  fi
  log "API token obtained successfully."
}

get_computer_inventory_id() {
    log "Looking up device by serial: '$serial'"
    local filter="hardware.serialNumber==\"$serial\""
    local filter_encoded=$(urlencode "$filter")
    local api_endpoint="$origin_jamf_url/api/v1/computers-inventory?section=GENERAL&filter=${filter_encoded}"

    log "Querying Jamf API: $api_endpoint"
    response=$(curl --connect-timeout 15 -s -L -w "\nHTTP_STATUS:%{http_code}" \
        -H "Authorization: Bearer $bearer_token" \
        "$api_endpoint")
    local curl_exit_code=$?
    if [[ $curl_exit_code -ne 0 ]]; then
         err "Failed to connect to Jamf Pro inventory endpoint ($origin_jamf_url). cURL error code: $curl_exit_code."
    fi

    http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
    response_body=$(echo "$response" | sed '$d')

    if [[ "$http_status" -ne 200 ]]; then
        err "Jamf API request failed (HTTP $http_status) when looking up device ID. Check API permissions ('Computers: Read'). Response: $response_body"
    fi
    if ! echo "$response_body" | jq empty; then err "Invalid JSON response received when looking up device ID. Response: $response_body"; fi
    
    local result_count=$(echo "$response_body" | jq -r '.totalCount // 0')
    if [[ "$result_count" -eq 0 ]]; then
        err "Device with serial number '$serial' was not found in the origin Jamf Pro instance ($origin_jamf_url). Cannot proceed."
    elif [[ "$result_count" -gt 1 ]]; then
         log "WARN: Multiple devices found with serial '$serial'. Using the first result." # Should not happen with serials
    fi

    computer_id=$(echo "$response_body" | jq -r '.results[0].id')
    management_id=$(echo "$response_body" | jq -r '.results[0].general.managementId')
    
    [[ -z "$computer_id" || "$computer_id" == "null" ]] && err "Computer ID could not be extracted from Jamf API response (Serial: $serial)."
    [[ -z "$management_id" || "$management_id" == "null" ]] && err "Management ID could not be extracted from Jamf API response (Serial: $serial)."

    success "Found Computer ID: $computer_id and Management ID: $management_id"
}

clear_failed_commands() {
  log "Attempting to clear failed/pending commands in Jamf Pro for Computer ID: $computer_id..."
  local payload='{"statuses": ["FAILED", "PENDING", "UNKNOWN"]}' # Include UNKNOWN just in case
  local api_endpoint="$origin_jamf_url/api/v1/computers-inventory/$computer_id/commands/flush"
  
  response=$(curl --connect-timeout 15 -s -L -w "\nHTTP_STATUS:%{http_code}" -X POST \
    "$api_endpoint" \
    -H "Authorization: Bearer $bearer_token" \
    -H "Content-Type: application/json" \
    -d "$payload")
   local curl_exit_code=$?
   if [[ $curl_exit_code -ne 0 ]]; then
        log "WARN: Failed to connect to command flush endpoint. cURL error: $curl_exit_code. Proceeding anyway."
        return
   fi

  http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
  response_body=$(echo "$response" | sed '$d')
  
  # Treat 202 Accepted as success as well
  if [[ "$http_status" -ge 200 && "$http_status" -lt 300 ]]; then
    success "Successfully requested command flush (HTTP $http_status)."
  else
    # Log detailed error but continue, as it's non-critical
    log "WARN: Could not clear failed/pending commands (HTTP $http_status). This is non-critical, proceeding anyway. Response: $response_body"
  fi
}

trigger_remote_wipe() {
    # Refresh token right before sending the command
    log "Refreshing API token before sending wipe command..."
    get_jamf_auth_token

    log "Initiating remote wipe ('Erase All Content and Settings') via Jamf Pro API v2..."
    
    if $dry_run; then
        log "[DRY-RUN] Would have sent 'Erase All Content and Settings' command (Obliteration: Default) for management ID $management_id."
        success "[DRY-RUN] Remote wipe would have been initiated."
        return
    fi
    
    # Display the final info dialog as the user, run in background
    sudo -u "$LOGGED_IN_USER" "$DIALOG_BINARY" --title "Wipe Command Sent" \
      --message "The 'Erase All Content and Settings' command has been sent to this Mac. \n\nIt will restart to the setup screen shortly. \n\nThis window will close automatically after the command is sent." \
      --icon "$BRANDING_ICON" --width 450 --height 250 --messagefont "size=12" \
      --button1text "OK" --infobox & # Run in background, no need to wait

    # Give the dialog a moment to appear
    sleep 2
    
    # Payload for /v2/mdm/commands using "Default" obliteration behavior (Erase All Content & Settings)
    local payload
    # Removed pin as it's not strictly needed for Default obliteration and can sometimes cause issues
    payload=$(printf '{
      "commandData": {
        "commandType": "ERASE_DEVICE",
        "obliterationBehavior": "Default" 
      },
      "clientData": [{"managementId": "%s"}]
    }' "$management_id")

    local api_endpoint="$origin_jamf_url/api/v2/mdm/commands"
    log "Sending wipe command to: $api_endpoint"
    log "Payload (excluding sensitive data if any): $payload" 

    response=$(curl --connect-timeout 20 -s -L -w "\nHTTP_STATUS:%{http_code}" -X POST \
        "$api_endpoint" \
        -H "Authorization: Bearer $bearer_token" \
        -H "Content-Type: application/json" \
        -d "$payload")
    local curl_exit_code=$?
    # Kill the info dialog immediately after the command is sent, regardless of success/failure
    pkill -f "$DIALOG_BINARY.*Wipe Command Sent" &>/dev/null 

    if [[ $curl_exit_code -ne 0 ]]; then
         err "Failed to connect to Jamf Pro MDM command endpoint ($api_endpoint). cURL error code: $curl_exit_code. Wipe command may not have been sent."
    fi

    http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
    response_body=$(echo "$response" | sed '$d')
    
    # Check for success (2xx range - typically 201 Created or 202 Accepted)
    if [[ "$http_status" -ge 200 && "$http_status" -lt 300 ]]; then
        success "EraseDevice command sent successfully (HTTP $http_status). The device should begin erasing shortly. Script will now exit."
        log "Jamf API Response: $response_body" # Log success response for confirmation
        exit 0 # Crucial clean exit
    else
        # Provide more detailed error logging
        err "Failed to send EraseDevice command (HTTP $http_status). Please contact IT Support. Check Jamf Pro logs for details. Response: $response_body"
    fi
}


#
# ─── MAIN EXECUTION ───────────────────────────────────────────────────────────
#

main() {
  # Run initial setup and hardware check immediately
  setup_environment
  check_hardware_support 
  
  # Handle deferral logic
  check_deferral
  
  # Show interactive requirements checklist
  show_requirements_dialog

  # --- Run remaining preflight checks ---
  log "Proceeding with automated preflight checks..."
  check_os_version
  check_disk_space 
  check_device_power_type 
  get_connection_type
  check_time_sync 
  check_onedrive_status 
  check_apns_connectivity # Changed to warning if fails
  check_jamf_enrollment
  check_mdm_profile
  
  log "All automated preflight checks passed (or generated warnings)."

  # --- Get Jamf Info & Clear Commands ---
  log "Connecting to Jamf Pro API..."
  get_jamf_auth_token
  get_computer_inventory_id
  clear_failed_commands

  # --- Final User Confirmation & App Kill ---
  log "Displaying final confirmation dialog..."
  # Run dialog as user
  if ! sudo -u "$LOGGED_IN_USER" "$DIALOG_BINARY" --title "Final Confirmation - Wipe Device?" \
       --message "All checks passed. All applications (except critical system services) will now be closed and the device will be wiped using 'Erase All Content and Settings'.\n\n**THIS IS YOUR LAST CHANCE TO CANCEL.**\n\nClick 'Wipe Mac Now' to proceed." \
       --icon "$BRANDING_ICON" --width 550 --height 350 --messagefont "size=12" \
       --button1text "Wipe Mac Now" --button2text "Cancel"; then
      log "User cancelled at the final confirmation stage."
      exit 0
  fi
  
  log "User confirmed wipe. Proceeding to kill applications..."
  kill_user_apps

  # --- Execute Wipe ---
  log "Executing wipe command..."
  if $dry_run; then
    success "[DRY-RUN] Migration would have proceeded. Device wipe command not sent."
    show_dialog_info "Dry-Run Complete" "All checks passed successfully. In a real run, the wipe command would have been sent."
  else
    trigger_remote_wipe
  fi
  
  log "Script finished (or wipe command failed before exit)." 
  exit 0 
}

# --- Script Entry Point ---

# Ensure script is run as root
if [[ $EUID -ne 0 ]]; then
   # Log to system log if possible
   syslog -s -k Facility com.apple.console Level Error Sender "$0" Message "ERROR: This script must be run as root (e.g., via Jamf Pro policy)."
   echo "ERROR: This script must be run as root."
   exit 1
fi

# Kick off the main function, passing any original script arguments along
main "$@"

