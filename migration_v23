#!/bin/zsh

#
# ─── SCRIPT CONFIGURATION ─────────────────────────────────────────────────────
#

# --- Deferral Settings ---
MAX_DEFERRALS=5
PLIST_PATH="/Library/Application Support/LBG/com.lbg.jamf-migration.plist"
LOGGED_IN_USER=$(scutil <<< "show State:/Users/ConsoleUser" | awk '/Name :/ && ! /loginwindow/ { print $3 }')
LAUNCH_AGENT_PATH="/Users/$LOGGED_IN_USER/Library/LaunchAgents/com.lbg.jamf-migration.plist"


# --- SwiftDialog Settings ---
DIALOG_BINARY="/usr/local/bin/dialog"
# This should point to the icon in your local branding package
BRANDING_ICON="/Users/Shared/LBG_Branding_Cancara/lbg_primary_logo.png" 

# --- Jamf API Credentials & Endpoints ---
JAMF_CLIENT_ID="${4:-$JAMF_CLIENT_ID}"
JAMF_CLIENT_SECRET="${5:-$JAMF_CLIENT_SECRET}"
ORIGIN_JAMF_URL="${6:-$ORIGIN_JAMF_URL}"
TARGET_JAMF_URL="${7:-$TARGET_JAMF_URL}"
DRY_RUN="${8:-${DRY_RUN:-false}}"

# --- Global Variables ---
management_id=""
computer_id=""

#
# ─── LOGGING AND UTILITIES ────────────────────────────────────────────────────
#

LOG_FILE="/Users/$LOGGED_IN_USER/jamf_migration_preflight.log"
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'; NC='\033[0m'

log() {
  printf '%b[%s] [INFO]  %s%b\n' \
    "$YELLOW" "$(date '+%Y-%m-%dT%H:%M:%S')" "$1" "$NC" | tee -a "$LOG_FILE"
}

success() {
  printf '%b[%s] [SUCCESS] %s%b\n' \
    "$GREEN" "$(date '+%Y-%m-%dT%H:%M:%S')" "$1" "$NC" | tee -a "$LOG_FILE"
}

err() {
  printf '%b[%s] [ERROR] %s%b\n' \
    "$RED" "$(date '+%Y-%m-%dT%H:%M:%S')" "$1" "$NC" | tee -a "$LOG_FILE" >&2
  # Avoid showing dialog if already exiting due to dialog interaction
  if [[ "$?" -ne 2 && "$?" -ne 3 ]]; then # 2=Cancel, 3=Quit
      show_dialog_error "$1"
  fi
  exit 1
}

run_cmd() {
  if $dry_run && [[ "$1" == "kill" ]]; then
    log "[DRY-RUN] Would execute: $*"
  else
    "$@"
  fi
}

urlencode() {
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * )               printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "${encoded}"
}


#
# ─── SWIFTDIALOG FUNCTIONS ────────────────────────────────────────────────────
#

show_dialog_error() {
  "$DIALOG_BINARY" --title "Migration Error" --message "$1" --icon "SF=xmark.octagon.fill,colour=red" \
    --button1text "Close" --width 450 --height 250 --messagefont "size=12" --json &>/dev/null 
    # Capture output to avoid errors if dialog fails, ignore json output
}

show_dialog_info() {
    "$DIALOG_BINARY" --title "$1" --message "$2" --icon "$BRANDING_ICON" \
      --button1text "OK" --width 450 --height 250 --messagefont "size=12" --json &>/dev/null
}

show_dialog_confirm() {
    # Returns 0 if Button 1 pressed, 2 if Button 2 pressed
    "$DIALOG_BINARY" --title "$1" --message "$2" --icon "$BRANDING_ICON" \
      --button1text "${3:-Proceed}" --button2text "${4:-Cancel}" --width 550 --height 350 --messagefont "size=12" --json &>/dev/null
    return $?
}


#
# ─── DEFERRAL & SCHEDULING FUNCTIONS ──────────────────────────────────────────
#

schedule_relaunch() {
    local schedule_type="$1"
    local current_hour=$(date +%H)
    local current_minute=$(date +%M)
    local target_hour
    local target_minute
    local target_day
    local target_month
    local target_year

    log "Scheduling relaunch based on type: $schedule_type"

    case "$schedule_type" in
        "1hour")
            target_hour=$(date -v+1H +%H)
            target_minute=$(date -v+1H +%M)
            target_day=$(date -v+1H +%d)
            target_month=$(date -v+1H +%m)
            target_year=$(date -v+1H +%Y)
            ;;
        "2hour")
            target_hour=$(date -v+2H +%H)
            target_minute=$(date -v+2H +%M)
            target_day=$(date -v+2H +%d)
            target_month=$(date -v+2H +%m)
            target_year=$(date -v+2H +%Y)
            ;;
        "tomorrow9am")
            target_hour=9
            target_minute=0
            target_day=$(date -v+1d +%d)
            target_month=$(date -v+1d +%m)
            target_year=$(date -v+1d +%Y)
            ;;
        "eod") # End of Day (Today 5 PM)
            target_hour=17
            target_minute=0
            target_day=$(date +%d)
            target_month=$(date +%m)
            target_year=$(date +%Y)
            # If it's already past 5 PM, schedule for tomorrow 5 PM
            if [[ "$current_hour" -ge 17 ]]; then
                log "Current time is past 5 PM, scheduling for tomorrow 5 PM."
                target_day=$(date -v+1d +%d)
                target_month=$(date -v+1d +%m)
                target_year=$(date -v+1d +%Y)
            fi
            ;;
        "1day") # In 1 Day (Tomorrow at current time, effectively) - Let's make it 9 AM for consistency
            target_hour=9
            target_minute=0
            target_day=$(date -v+1d +%d)
            target_month=$(date -v+1d +%m)
            target_year=$(date -v+1d +%Y)
            ;;
        *)
            log "ERROR: Invalid schedule type '$schedule_type'"
            return 1
            ;;
    esac

    log "Calculated Target - Year:$target_year, Month:$target_month, Day:$target_day, Hour:$target_hour, Minute:$target_minute"

    # Unload any existing agent
    if [ -f "$LAUNCH_AGENT_PATH" ]; then
        launchctl bootout "gui/$(id -u "$LOGGED_IN_USER")" "$LAUNCH_AGENT_PATH" &>/dev/null
    fi

    # Create the launch agent plist using StartCalendarInterval
    cat << EOF > "$LAUNCH_AGENT_PATH"
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.lbg.jamf-migration</string>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/zsh</string>
        <string>$0</string> <!-- Rerun this script -->
    </array>
    <key>StartCalendarInterval</key>
    <dict>
        <key>Year</key>
        <integer>$target_year</integer>
        <key>Month</key>
        <integer>$target_month</integer>
        <key>Day</key>
        <integer>$target_day</integer>
        <key>Hour</key>
        <integer>$target_hour</integer>
        <key>Minute</key>
        <integer>$target_minute</integer>
    </dict>
    <key>RunAtLoad</key>
    <false/>
</dict>
</plist>
EOF

    # Set correct ownership and permissions
    chown "$LOGGED_IN_USER" "$LAUNCH_AGENT_PATH"
    chmod 644 "$LAUNCH_AGENT_PATH"

    # Load the new agent
    launchctl bootstrap "gui/$(id -u "$LOGGED_IN_USER")" "$LAUNCH_AGENT_PATH"
    log "Launch Agent loaded and scheduled for $target_year-$target_month-$target_day $target_hour:$target_minute."
}


remove_relaunch_agent() {
    if [ -f "$LAUNCH_AGENT_PATH" ]; then
        log "Removing relaunch agent."
        launchctl bootout "gui/$(id -u "$LOGGED_IN_USER")" "$LAUNCH_AGENT_PATH" &>/dev/null
        rm "$LAUNCH_AGENT_PATH"
    fi
}

handle_deferral() {
    deferral_count=$((deferral_count + 1))
    defaults write "$PLIST_PATH" DeferralCount -int "$deferral_count"
    log "User deferred. New count: $deferral_count."

    # Use SwiftDialog dropdown for deferral options
    defer_choice_output=$("$DIALOG_BINARY" --title "Choose Deferral Time" \
      --message "When should we remind you?\n\nYou have $((MAX_DEFERRALS - deferral_count)) deferrals remaining." \
      --icon "$BRANDING_ICON" --width 450 --height 280 --messagefont "size=12" \
      --selecttitle "Deferral Options" --selectvalues "1hour, 2hour, tomorrow9am, eod, 1day" \
      --selectdefault "1hour" \
      --selectrequired \
      --button1text "Confirm Deferral" --button2text "Cancel" --json)
      
    defer_choice_exit_code=$?
    
    if [[ $defer_choice_exit_code -eq 2 ]]; then
        log "User cancelled deferral selection."
        exit 0 # Exit gracefully if user cancels the deferral choice itself
    elif [[ $defer_choice_exit_code -ne 0 ]]; then
        err "Error displaying deferral options dialog." # Or exit 0? Assume error
    fi

    selected_deferral=$(echo "$defer_choice_output" | jq -r '.SelectedOption')

    if [[ -z "$selected_deferral" || "$selected_deferral" == "null" ]]; then
        err "Could not determine selected deferral option."
    fi

    log "User selected deferral: $selected_deferral"

    local defer_message=""
    case "$selected_deferral" in
        "1hour") defer_message="You will be reminded in 1 hour." ;;
        "2hour") defer_message="You will be reminded in 2 hours." ;;
        "tomorrow9am") defer_message="You will be reminded tomorrow at 9 AM." ;;
        "eod") 
            if [[ $(date +%H) -ge 17 ]]; then
                 defer_message="You will be reminded tomorrow at 5 PM."
            else
                 defer_message="You will be reminded today at 5 PM."
            fi
            ;;
        "1day") defer_message="You will be reminded tomorrow at 9 AM." ;; 
        *) 
            err "Invalid deferral option selected: $selected_deferral" ;;
    esac

    schedule_relaunch "$selected_deferral"
    show_dialog_info "Migration Deferred" "$defer_message"
    exit 0
}


check_deferral() {
  if [ ! -f "$PLIST_PATH" ]; then
    log "Plist not found. Creating with 0 deferrals."
    mkdir -p "$(dirname "$PLIST_PATH")"
    defaults write "$PLIST_PATH" DeferralCount -int 0
  fi
  
  deferral_count=$(defaults read "$PLIST_PATH" DeferralCount 2>/dev/null || echo 0)
  remaining_deferrals=$((MAX_DEFERRALS - deferral_count))

  log "Deferral count: $deferral_count. Remaining: $remaining_deferrals."

  if [ "$remaining_deferrals" -le 0 ]; then
    show_dialog_info "Mandatory Migration" "The migration is now mandatory.\nPlease save your work, the process will begin automatically after closing this window."
    remove_relaunch_agent # Clean up scheduler as it's no longer needed
  else
    if show_dialog_confirm "Jamf Pro Migration Required" "This Mac needs to be migrated to a new management system.\n\nYou have $remaining_deferrals deferrals remaining." "Migrate Now" "Defer"; then
        log "User chose to migrate now."
        remove_relaunch_agent # Clean up scheduler
    else
        log "User chose to defer."
        handle_deferral # Exits the script after handling deferral
    fi
  fi
}

show_requirements_dialog() {
    local power_status_checked="false"
    local power_status_icon="xmark.circle.fill"
    local power_status_colour="red"
    if pmset -g batt | grep -q "AC Power"; then
        power_status_checked="true"
        power_status_icon="checkmark.circle.fill"
        power_status_colour="green"
    fi
    
    local dialog_cmd
    local dialog_output
    local dialog_exit_code
    local backup_confirmed="false"

    while [[ "$backup_confirmed" != "true" ]]; do
        dialog_cmd=(
            "$DIALOG_BINARY"
            --title "Migration Requirements Checklist"
            --message "Please confirm the following before proceeding.\n**This process will wipe all data from your Mac.**"
            --icon "$BRANDING_ICON"
            --width 650 --height 450 --messagefont "size=12" --alignment "left"
            --checkbox "label: **Power:** Your Mac is connected to a power adapter.", "checked=$power_status_checked", "disabled", "icon=$power_status_icon", "colour=$power_status_colour"
            --checkbox "label: **Internet:** You have a stable internet connection.", "required", "icon=wifi"
            --checkbox "label: **Disk Space:** You have at least 5 GB of free disk space.", "required", "icon=opticaldiscdrive"
            --checkbox "label: **OneDrive Backup:** I confirm all important data is saved/synced to OneDrive.", "required", "icon=icloud.and.arrow.up.fill"
            --checkbox "label: **Time Sync:** System clock is set automatically.", "required", "icon=clock.fill"
            --button1text "Continue"
            --button2text "Cancel"
            --json
        )

        dialog_output=$("${dialog_cmd[@]}")
        dialog_exit_code=$?

        log "Requirements dialog exit code: $dialog_exit_code"
        log "Requirements dialog output: $dialog_output" # Log the JSON output for debugging

        if [[ $dialog_exit_code -eq 2 ]]; then
            log "User cancelled at the requirements checklist."
            exit 0 # Exit gracefully
        elif [[ $dialog_exit_code -ne 0 ]]; then
            err "Error displaying requirements dialog."
        fi

        # Extract the state of the OneDrive backup checkbox
        # Checkbox indices start from 1. Assuming OneDrive is the 4th checkbox.
        backup_confirmed=$(echo "$dialog_output" | jq -r '.checkbox[3].checked // "false"')

        if [[ "$backup_confirmed" != "true" ]]; then
            show_dialog_error "Backup Confirmation Required\n\nYou must confirm that your data is backed up to OneDrive before proceeding with the wipe."
            # Loop will continue
        else
            log "All required checkboxes confirmed by user."
            # Check other required checkboxes just in case (Internet, Disk Space, Time Sync)
             local internet_ok=$(echo "$dialog_output" | jq -r '.checkbox[1].checked // "false"')
             local disk_ok=$(echo "$dialog_output" | jq -r '.checkbox[2].checked // "false"')
             local time_ok=$(echo "$dialog_output" | jq -r '.checkbox[4].checked // "false"')
             
             if [[ "$internet_ok" != "true" || "$disk_ok" != "true" || "$time_ok" != "true" ]]; then
                 show_dialog_error "Confirmation Required\n\nPlease confirm all required items (Internet, Disk Space, Time Sync) before proceeding."
                 backup_confirmed="false" # Force loop to repeat
             fi
        fi
    done
    success "User confirmed all migration requirements."
}



#
# ─── ENVIRONMENT & PREFLIGHT CHECKS ───────────────────────────────────────────
#

setup_environment() {
    # Validate required parameters
    local missing_params=false
    local error_msg="Missing required parameters:"

    if [ -z "$JAMF_CLIENT_ID" ]; then error_msg+="\n- JAMF_CLIENT_ID"; missing_params=true; fi
    if [ -z "$JAMF_CLIENT_SECRET" ]; then error_msg+="\n- JAMF_CLIENT_SECRET"; missing_params=true; fi
    if [ -z "$ORIGIN_JAMF_URL" ]; then error_msg+="\n- ORIGIN_JAMF_URL"; missing_params=true; fi
    if [ -z "$TARGET_JAMF_URL" ]; then error_msg+="\n- TARGET_JAMF_URL"; missing_params=true; fi

    if $missing_params; then
      err "$error_msg"
    fi

    client_id="$JAMF_CLIENT_ID"
    client_secret="$JAMF_CLIENT_SECRET"
    origin_jamf_url="${ORIGIN_JAMF_URL%/}"
    target_jamf_url="${TARGET_JAMF_URL%/}"
    dry_run=$(echo "$DRY_RUN" | tr '[:upper:]' '[:lower:]')
    [[ "$dry_run" == "true" ]] && dry_run=true || dry_run=false

    log_dir=$(dirname "$LOG_FILE")
    mkdir -p "$log_dir" 2>/dev/null
    touch "$LOG_FILE" 2>/dev/null || { echo "ERROR: Cannot write to log file $LOG_FILE"; exit 1; }
    
    serial=$(system_profiler SPHardwareDataType | awk '/Serial/ {print $4}')
    [ -z "$serial" ] && err "Could not determine serial number."
}

check_hardware_support() {
    log "Checking hardware for Apple Silicon..."
    if ! sysctl -n machdep.cpu.brand_string | grep -q "Apple"; then
        err "This device is not an Apple Silicon Mac and is no longer supported. Please follow the process to order a new device."
    fi
    success "Apple Silicon Mac detected. Device is supported."
}

check_os_version() {
    log "Checking macOS version..."
    OS_VERSION=$(sw_vers -productVersion)
    local os_major_version
    os_major_version=$(echo "$OS_VERSION" | awk -F. '{print $1}')

    if [[ "$os_major_version" -lt 12 ]]; then
        err "macOS version ($OS_VERSION) is older than macOS 12. This migration requires macOS 12 or newer."
    else
        success "macOS version ($OS_VERSION) is supported."
    fi
}

get_connection_type() {
  log "Checking internet connection..."
  # Use a reliable target and increase timeout slightly
  if ! curl -s --head --connect-timeout 10 "https://www.apple.com/" >/dev/null 2>&1; then
    err "No internet connectivity detected (cannot reach apple.com). Migration requires an active internet connection."
  fi
  success "Internet connectivity check passed."
}

check_device_power_type() {
  log "Checking power source..."
  # This check is informational now, confirmation happens in the dialog
  if pmset -g batt | grep -q "AC Power"; then
    success "Device is connected to AC power."
  else
    log "WARN: Device is running on battery power. User must confirm connection in dialog."
    # Don't err here, let the dialog handle it.
  fi
}

check_mdm_profile() {
  log "Checking for active MDM profile..."
  # Check more reliably using the profiles command
  if ! profiles show -type enrollment &>/dev/null; then
    # Fallback check
    if ! profiles status -type enrollment | grep -q "Enrolled via DEP:"; then
        err "No active MDM profile was detected. This device must be enrolled in MDM to proceed."
    fi
  fi
  success "Active MDM profile detected."
}


check_jamf_enrollment() {
  log "Verifying current Jamf Pro enrollment status..."
  if [[ ! -f "/usr/local/bin/jamf" && ! -f "/usr/local/jamf/bin/jamf" ]]; then
    err "Jamf binary not found - device may not be enrolled in any Jamf Pro instance."
  fi
  
  local current_jss_url
  # Check standard plist location first
  if [[ -f "/Library/Preferences/com.jamfsoftware.jamf.plist" ]]; then
      current_jss_url=$(/usr/bin/defaults read /Library/Preferences/com.jamfsoftware.jamf.plist jss_url 2>/dev/null)
  fi

  # Fallback: Ask jamf binary directly if plist read fails
  if [[ -z "$current_jss_url" ]]; then
       local jamf_binary
       if [[ -f "/usr/local/bin/jamf" ]]; then jamf_binary="/usr/local/bin/jamf"; 
       elif [[ -f "/usr/local/jamf/bin/jamf" ]]; then jamf_binary="/usr/local/jamf/bin/jamf"; fi
       
       if [[ -n "$jamf_binary" ]]; then
           current_jss_url=$("$jamf_binary" checkJSSConnection -dump | awk '/url: / {print $2}')
       fi
  fi


  if [[ -z "$current_jss_url" ]]; then
      err "Could not determine the current Jamf Pro server URL."
  fi

  log "Current Jamf URL found: $current_jss_url"
  
  if [[ "$current_jss_url" == "$target_jamf_url"* ]]; then
    err "Device is already enrolled in the target Jamf Pro instance ($target_jamf_url). Migration unnecessary."
  elif [[ "$current_jss_url" != "$origin_jamf_url"* ]]; then
    err "Device is enrolled in an unexpected Jamf Pro instance ($current_jss_url), not the expected origin ($origin_jamf_url). Cannot proceed."
  else
    success "Confirmed device is enrolled in the correct origin Jamf instance ($origin_jamf_url)."
  fi
}

check_onedrive_status() {
    log "Checking OneDrive installation..."
    # Only check if it's installed, running status checked by user in dialog
    if [[ ! -d "/Applications/OneDrive.app" ]]; then
        err "OneDrive.app is not installed. OneDrive sync is required before proceeding."
    fi
    success "OneDrive application is installed."
    # Note: We rely on the user confirming sync status in the requirements dialog.
}


kill_user_apps() {
  # Added more essential system processes and common security/network tools
  local excluded_patterns=(
      "Self Service" "Terminal" "Finder" "dialog" "jamf" "Jamf" "loginwindow" 
      "WindowServer" "SystemUIServer" "Dock" "mds" "Spotlight" "NotificationCenter"
      "Symantec" "WSS" "Microsoft Defender" "MsSense" "wdav" # Symantec WSS & Defender patterns
      "CoreServicesUIAgent" "ControlCenter" "SoftwareUpdateNotificationManager"
      "OneDrive" # Keep OneDrive running if possible during quit phase
      "SecurityAgent"
      )
  log "Starting graceful application termination (excluding critical processes)..."
  
  local app_pids=()
  # Use `pgrep` for more reliable process matching by path
  pgrep -if "/Applications/.*\.app/" | while read -r pid; do
      local command
      command=$(ps -p "$pid" -o command=)
      # Skip if no command string (e.g., zombie process)
      [[ -z "$command" ]] && continue
      
      local app_name
      # More robust extraction of app name
      app_name=$(echo "$command" | awk -F'/Contents/MacOS/' '{print $1}' | awk -F'/' '{print $NF}' | sed 's/\.app$//')
      
      local excluded=false
      for pattern in "${excluded_patterns[@]}"; do
        # Check against both the command path and the extracted app name
        if [[ "$command" == *"$pattern"* ]] || [[ "$app_name" == *"$pattern"* ]]; then
          log "Excluding critical process: $app_name ($command)"
          excluded=true
          break
        fi
      done
    
      if ! $excluded; then
        log "Attempting graceful termination of $app_name (PID: $pid)"
        # Use kill -TERM first for a more standard graceful signal
        run_cmd kill -TERM "$pid" &>/dev/null &
        app_pids+=("$pid")
      fi
  done
  
  # Increased wait time for graceful shutdown
  log "Waiting 5 seconds for applications to close gracefully..."
  sleep 5
  
  log "Checking for remaining processes to force quit..."
  for pid in "${app_pids[@]}"; do
    # Check if process still exists
    if kill -0 "$pid" &>/dev/null; then
      local remaining_app_name=$(ps -p "$pid" -o comm=)
      log "Force killing remaining process: $remaining_app_name (PID: $pid)"
      run_cmd kill -KILL "$pid"
    fi
  done
  success "Application termination process complete."
}


check_apns_connectivity() {
  log "Checking connectivity to Apple Push Notification Service (APNs)..."
  # Use curl as nc might be blocked, target a known Apple host
  if curl -s --head --connect-timeout 10 "https://api.push.apple.com/" >/dev/null 2>&1; then
    success "APNs hostname (api.push.apple.com) is reachable."
  else
    err "Cannot reach APNs (api.push.apple.com). This may be due to network restrictions or a firewall. The wipe command may fail."
  fi
}

check_time_sync() {
  log "Checking system clock sync setting..."
  # Check if automatic time sync is enabled, rather than relying on sntp offset which can fail over network
  if ! systemsetup -getusingnetworktime | grep -q "On"; then
       err "Automatic time synchronization is not enabled. Please enable 'Set time and date automatically' in System Settings > General > Date & Time."
  fi
  success "Automatic time synchronization is enabled."
}

check_disk_space() {
  log "Checking available disk space..."
  local free_space_gb
  # Get free space in GB using -g flag
  free_space_gb=$(df -g / | tail -1 | awk '{print $4}')
  
  local required_space=5 # Minimum required for Erase All Content and Settings
  
  log "Available disk space: ${free_space_gb}GB"
  if [[ "$free_space_gb" -lt "$required_space" ]]; then
    err "Less than ${required_space} GB of free disk space available (${free_space_gb}GB found). Please free up space to continue."
  else
    success "Disk space sufficient (${free_space_gb}GB free)."
  fi
}


#
# ─── JAMF PRO API FUNCTIONS ───────────────────────────────────────────────────
#

get_jamf_auth_token() {
  log "Getting API token from origin Jamf: $origin_jamf_url"
  response=$(
    curl -s -X POST "$origin_jamf_url/api/v1/oauth/token" \
      -H "accept: application/json" \
      -H "content-type: application/x-www-form-urlencoded" \
      -d "grant_type=client_credentials&client_id=$client_id&client_secret=$client_secret"
  )
  
  # Add better error checking for token retrieval
  if [[ -z "$response" ]]; then
      err "Failed to get API token: No response from server."
  fi
  
  bearer_token=$(echo "$response" | jq -r '.access_token')
  
  if [[ -z "$bearer_token" || "$bearer_token" == "null" ]]; then
      local error_details=$(echo "$response" | jq -r '.') # Log full error if possible
      err "Failed to get API token from Jamf Pro. Check credentials and API role permissions. Details: $error_details"
  fi
  
  success "API token obtained successfully."
}

get_computer_inventory_id() {
    log "Looking up device by serial: '$serial'"
    local filter="hardware.serialNumber==\"$serial\""
    local filter_encoded
    filter_encoded=$(urlencode "$filter")

    response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
        -H "Authorization: Bearer $bearer_token" \
        "$origin_jamf_url/api/v1/computers-inventory?section=GENERAL&filter=${filter_encoded}")
    
    http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
    response_body=$(echo "$response" | sed '$d')

    if [[ "$http_status" -ne 200 ]]; then
        err "Jamf API request failed (HTTP $http_status) when looking up device. Response: $response_body"
    fi
    
    local result_count=$(echo "$response_body" | jq -r '.totalCount // 0')
    if [[ "$result_count" -eq 0 ]]; then
        err "Device with serial number '$serial' not found in the origin Jamf Pro instance ($origin_jamf_url)."
    fi

    computer_id=$(echo "$response_body" | jq -r '.results[0].id')
    management_id=$(echo "$response_body" | jq -r '.results[0].general.managementId')
    
    [[ -z "$computer_id" || "$computer_id" == "null" ]] && err "Computer ID not found in Jamf Pro API response."
    [[ -z "$management_id" || "$management_id" == "null" ]] && err "Management ID not found in Jamf Pro API response."

    success "Found Computer ID: $computer_id and Management ID: $management_id"
}

clear_failed_commands() {
  log "Attempting to clear failed/pending commands in Jamf Pro for Computer ID: $computer_id..."
  local payload='{"statuses": ["FAILED", "PENDING"]}'
  
  response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
    "$origin_jamf_url/api/v1/computers-inventory/$computer_id/commands/flush" \
    -H "Authorization: Bearer $bearer_token" \
    -H "Content-Type: application/json" \
    -d "$payload")

  http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
  response_body=$(echo "$response" | sed '$d')
  
  if [[ "$http_status" -ge 200 && "$http_status" -lt 300 ]]; then
    success "Successfully cleared failed/pending commands (HTTP $http_status)."
  else
    # Log detailed error but continue
    log "WARN: Could not clear failed commands (HTTP $http_status). This is non-critical, proceeding anyway. Response: $response_body"
  fi
}

trigger_remote_wipe() {
    log "Initiating remote wipe ('Erase All Content and Settings') via Jamf Pro API v2..."
    
    if $dry_run; then
        log "[DRY-RUN] Would have sent 'Erase All Content and Settings' command for management ID $management_id."
        success "[DRY-RUN] Remote wipe would have been initiated."
        return
    fi
    
    show_dialog_info "Wipe Command Sent" "The 'Erase All Content and Settings' command has been sent to this Mac. It will restart to the setup screen shortly."
    
    # Payload for /v2/mdm/commands using "Default" obliteration behavior
    local payload
    payload=$(printf '{
      "commandData": {
        "commandType": "ERASE_DEVICE",
        "obliterationBehavior": "Default",
        "pin": "123456" 
      },
      "clientData": [{"managementId": "%s"}]
    }' "$management_id")

    # The correct endpoint for this command
    response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
        "$origin_jamf_url/api/v2/mdm/commands" \
        -H "Authorization: Bearer $bearer_token" \
        -H "Content-Type: application/json" \
        -d "$payload")

    http_status=$(echo "$response" | tail -n1 | cut -d: -f2)
    response_body=$(echo "$response" | sed '$d')
    
    # Check for success (2xx range)
    if [[ "$http_status" -ge 200 && "$http_status" -lt 300 ]]; then
        success "EraseDevice command sent successfully (HTTP $http_status). The device should begin erasing shortly."
        # It's crucial to exit cleanly here so Jamf doesn't report a script failure
        exit 0
    else
        # Provide more detailed error logging
        err "Failed to send EraseDevice command (HTTP $http_status). Response: $response_body"
    fi
}


#
# ─── MAIN EXECUTION ───────────────────────────────────────────────────────────
#

main() {
  # Run initial setup and hardware check immediately
  setup_environment
  check_hardware_support 
  
  # Handle deferral logic
  check_deferral
  
  # Show interactive requirements checklist
  show_requirements_dialog

  # --- Run remaining preflight checks ---
  log "Proceeding with automated preflight checks..."
  check_os_version
  check_disk_space 
  check_device_power_type # Still useful to log, even if confirmed by user
  get_connection_type
  check_time_sync # Check setting, not offset
  check_onedrive_status # Check installation, not sync status
  check_apns_connectivity
  check_jamf_enrollment
  check_mdm_profile
  
  log "All automated preflight checks passed."

  # --- Get Jamf Info & Clear Commands ---
  log "Connecting to Jamf Pro API..."
  get_jamf_auth_token
  get_computer_inventory_id
  clear_failed_commands

  # --- Final User Confirmation & App Kill ---
  log "Displaying final confirmation dialog..."
  if ! show_dialog_confirm "Final Confirmation - Wipe Device?" "All checks passed. All applications (except critical system services) will now be closed and the device will be wiped using 'Erase All Content and Settings'.\n\n**THIS IS YOUR LAST CHANCE TO CANCEL.**" "Wipe Mac Now" "Cancel"; then
      log "User cancelled at the final confirmation stage."
      exit 0
  fi
  
  log "User confirmed wipe. Proceeding to kill applications..."
  kill_user_apps

  # --- Execute Wipe ---
  log "Executing wipe command..."
  if $dry_run; then
    success "[DRY-RUN] Migration would have proceeded. Device wipe command not sent."
    show_dialog_info "Dry-Run Complete" "All checks passed successfully. In a real run, the wipe command would have been sent."
  else
    trigger_remote_wipe
  fi
  
  # If trigger_remote_wipe was successful, script exits within that function. 
  # If it failed, the err() function in trigger_remote_wipe would have exited.
  # This part should ideally not be reached in a non-dry run.
  log "Script finished." 
}

# Ensure script is run as root
if [[ $EUID -ne 0 ]]; then
   log "ERROR: This script must be run as root (e.g., via Jamf Pro policy)."
   # Cannot use err() here as SwiftDialog might not be available or run correctly
   echo "ERROR: This script must be run as root."
   exit 1
fi

# Kick off the main function
main "$@"

